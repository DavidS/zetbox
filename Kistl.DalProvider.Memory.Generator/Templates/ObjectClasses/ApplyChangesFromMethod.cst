<%@ CodeTemplate Language="C#" 
    Name="ObjectClasses.ApplyChangesFromMethod"
    ClassName="Kistl.DalProvider.Memory.Generator.Templates.ObjectClasses.ApplyChangesFromMethod" 
    Inherits="Kistl.Generator.ResourceTemplate" %>
<%@ Import Namespace="System" %>
<%@ Import Namespace="System.Linq" %>
<%@ Import Namespace="Kistl.API" %>
<%@ Import Namespace="Kistl.API.Server" %>
<%@ Import Namespace="Kistl.App.Base" %>
<%@ Import Namespace="Kistl.Generator" %>
<%@ Import Namespace="Kistl.Generator.Extensions" %>
<%@ Parameter Name="ctx" Type="IKistlContext" %>
<%@ Parameter Name="otherInterface" Type="string" %>
<%@ Parameter Name="cls" Type="DataType" %>
<%@ Parameter Name="clsName" Type="string" %>
<%@ Parameter Name="implName" Type="string" %>

        public override void ApplyChangesFrom(<%= otherInterface %> obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (<%= clsName %>)obj;
            var otherImpl = (<%= implName %>)obj;
            var me = (<%= clsName %>)this;

<% // Only Client and Menory objects are applying calculated properties. NH + EF are re-calculating those properties when a depended object has changed. %>
<% foreach(var prop in cls.Properties.OfType<ValueTypeProperty>().OrderBy(p => p.Name)) { %>
<%      if (prop.IsList) { %>
<%          if (prop.HasPersistentOrder) { %>
            SynchronizeLists(this._<%= prop.Name %>Collection, otherImpl._<%= prop.Name %>Collection);
<%          } else { %>
            SynchronizeCollections(this._<%= prop.Name %>Collection, otherImpl._<%= prop.Name %>Collection);
<%          } %>
<%      } else { %>
<%			if(prop.IsCalculated) { %>
            this._<%= prop.Name %> = otherImpl._<%= prop.Name %>;
			this._<%= prop.Name %>_IsDirty = false;
<%			} else { %>
            me.<%= prop.Name %> = other.<%= prop.Name %>;
<%			} %>
<%      } %>
<% } %>
<% foreach(var prop in cls.Properties.OfType<CompoundObjectProperty>()/*.Where(p => !p.IsCalculated)*/.OrderBy(p => p.Name)) { %>
<%      if (prop.IsList) { %>
<%          if (prop.HasPersistentOrder) { %>
            SynchronizeLists(this._<%= prop.Name %>Collection, otherImpl._<%= prop.Name %>Collection);
<%          } else { %>
            SynchronizeCollections(this._<%= prop.Name %>Collection, otherImpl._<%= prop.Name %>Collection);
<%          } %>
<%      } else { %>
            if (me.<%= prop.Name %> == null && other.<%= prop.Name %> != null) {
                me.<%= prop.Name %> = (<%= prop.GetElementTypeString() %>)other.<%= prop.Name %>.Clone();
            } else if (me.<%= prop.Name %> != null && other.<%= prop.Name %> == null) {
                me.<%= prop.Name %> = null;
            } else if (me.<%= prop.Name %> != null && other.<%= prop.Name %> != null) {
                me.<%= prop.Name %>.ApplyChangesFrom(other.<%= prop.Name %>);
            }
<%      } %>
<% } %>
<% foreach(var prop in cls.Properties.OfType<ObjectReferenceProperty>().Where(p => !p.IsList()).OrderBy(p => p.Name)) {
        if (prop.RelationEnd.HasPersistentOrder) {
            var positionPropertyName = Construct.ListPositionPropertyName(prop.RelationEnd);
%>
            this.<%= positionPropertyName %> = otherImpl.<%= positionPropertyName %>;
<%      } %>
            this._fk_<%= prop.Name %> = otherImpl._fk_<%= prop.Name %>;
<% } %>
        }
