// <autogenerated/>

using System;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using System.Xml.Serialization;
using System.Linq;

using Kistl.API;
using Kistl.DalProvider.Base.RelationWrappers;
    using Kistl.DalProvider.Base;
    using Kistl.DalProvider.Memory;

namespace Kistl.App.Base
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("CalculatedObjectReferenceProperty_dependsOn_Property_RelationEntryMemoryImpl")]
    public class CalculatedObjectReferenceProperty_dependsOn_Property_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.Base.CalculatedObjectReferenceProperty, Kistl.App.Base.CalculatedObjectReferencePropertyMemoryImpl, Kistl.App.Base.Property, Kistl.App.Base.PropertyMemoryImpl>, CalculatedObjectReferenceProperty_dependsOn_Property_RelationEntry, Kistl.API.IExportableInternal, Kistl.App.Base.IExportable
    {
        [Obsolete]
        public CalculatedObjectReferenceProperty_dependsOn_Property_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public CalculatedObjectReferenceProperty_dependsOn_Property_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        // BEGIN Kistl.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(Guid);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                }
            }
        }
        private Guid _ExportGuid;
        // END Kistl.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("47595643-e8d0-48ef-82c7-2d24de8a784e");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.Base.CalculatedObjectReferenceProperty)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Base.Property)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.Base.CalculatedObjectReferenceProperty; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.CalculatedObjectReferenceProperty A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.Base.CalculatedObjectReferencePropertyMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;

        private Guid? _fk_guid_A = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.CalculatedObjectReferencePropertyMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.CalculatedObjectReferencePropertyMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.Base.CalculatedObjectReferencePropertyMemoryImpl)Context.Find<Kistl.App.Base.CalculatedObjectReferenceProperty>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Base.Property; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.Property B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Base.PropertyMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;

        private Guid? _fk_guid_B = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.PropertyMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.PropertyMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Base.PropertyMemoryImpl)Context.Find<Kistl.App.Base.Property>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._ExportGuid, binStream);
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._ExportGuid, binStream);
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.Base");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.Base");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.Base");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Kistl.App.Base");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Kistl.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_guid_A, xml, "A", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._fk_guid_B, xml, "B", "Kistl.App.Base");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(CalculatedObjectReferenceProperty_dependsOn_Property_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (CalculatedObjectReferenceProperty_dependsOn_Property_RelationEntryMemoryImpl)obj;
            var me = (CalculatedObjectReferenceProperty_dependsOn_Property_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Kistl.App.Base.CalculatedObjectReferencePropertyMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.CalculatedObjectReferenceProperty>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Kistl.App.Base.CalculatedObjectReferencePropertyMemoryImpl)Context.Find<Kistl.App.Base.CalculatedObjectReferenceProperty>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Kistl.App.Base.PropertyMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.Property>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Base.PropertyMemoryImpl)Context.Find<Kistl.App.Base.Property>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace at.dasz.DocumentManagement
{
	using Kistl.App.Base;
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Document_has_Blob_RelationEntryMemoryImpl")]
    public class Document_has_Blob_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<at.dasz.DocumentManagement.Document, at.dasz.DocumentManagement.DocumentMemoryImpl, Kistl.App.Base.Blob, Kistl.App.Base.BlobMemoryImpl>, Document_has_Blob_RelationEntry, Kistl.API.IExportableInternal, Kistl.App.Base.IExportable
    {
        [Obsolete]
        public Document_has_Blob_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public Document_has_Blob_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        // BEGIN Kistl.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(Guid);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                }
            }
        }
        private Guid _ExportGuid;
        // END Kistl.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("69d27812-e981-443b-a94b-dfe1a95f3aad");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (at.dasz.DocumentManagement.Document)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Base.Blob)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=at.dasz.DocumentManagement.Document; moduleNamespace=at.dasz.DocumentManagement;
        // inverse Navigator=none; is reference;
        // PositionStorage=A_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public at.dasz.DocumentManagement.Document A
        {
            get { return AImpl; }
            set { AImpl = (at.dasz.DocumentManagement.DocumentMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;

        private Guid? _fk_guid_A = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal at.dasz.DocumentManagement.DocumentMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                at.dasz.DocumentManagement.DocumentMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (at.dasz.DocumentManagement.DocumentMemoryImpl)Context.Find<at.dasz.DocumentManagement.Document>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // BEGIN Kistl.Generator.Templates.Properties.NotifyingValueProperty
        public int? A_pos
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int?);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _A_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_A_pos != value)
                {
                    var __oldValue = _A_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("A_pos", __oldValue, __newValue);
                    _A_pos = __newValue;
                    NotifyPropertyChanged("A_pos", __oldValue, __newValue);
                }
            }
        }
        private int? _A_pos;
        // END Kistl.Generator.Templates.Properties.NotifyingValueProperty
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Base.Blob; moduleNamespace=at.dasz.DocumentManagement;
        // inverse Navigator=none; is reference;
        // PositionStorage=B_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.Blob B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Base.BlobMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;

        private Guid? _fk_guid_B = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.BlobMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.BlobMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Base.BlobMemoryImpl)Context.Find<Kistl.App.Base.Blob>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // BEGIN Kistl.Generator.Templates.Properties.NotifyingValueProperty
        public int? B_pos
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int?);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _B_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_B_pos != value)
                {
                    var __oldValue = _B_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("B_pos", __oldValue, __newValue);
                    _B_pos = __newValue;
                    NotifyPropertyChanged("B_pos", __oldValue, __newValue);
                }
            }
        }
        private int? _B_pos;
        // END Kistl.Generator.Templates.Properties.NotifyingValueProperty
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        /// <summary>
        /// Index into the A-side list of this relation
        /// </summary>
        public int? AIndex { get { return _A_pos; } set { _A_pos = value; } }

        /// <summary>
        /// Index into the B-side list of this relation
        /// </summary>
        public int? BIndex { get { return _B_pos; } set { _B_pos = value; } }

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._ExportGuid, binStream);
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(this._A_pos, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
            BinarySerializer.ToStream(this._B_pos, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._ExportGuid, binStream);
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._A_pos, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            BinarySerializer.FromStream(out this._B_pos, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "at.dasz.DocumentManagement");
            XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "at.dasz.DocumentManagement");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "at.dasz.DocumentManagement");
            XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "at.dasz.DocumentManagement");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "at.dasz.DocumentManagement");
            XmlStreamer.FromStream(ref this._A_pos, xml, "A_pos", "at.dasz.DocumentManagement");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "at.dasz.DocumentManagement");
            XmlStreamer.FromStream(ref this._B_pos, xml, "B_pos", "at.dasz.DocumentManagement");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("at.dasz.DocumentManagement")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "at.dasz.DocumentManagement");
            if (modules.Contains("*") || modules.Contains("at.dasz.DocumentManagement")) XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "at.dasz.DocumentManagement");
            if (modules.Contains("*") || modules.Contains("at.dasz.DocumentManagement")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "at.dasz.DocumentManagement");
            if (modules.Contains("*") || modules.Contains("at.dasz.DocumentManagement")) XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "at.dasz.DocumentManagement");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_guid_A, xml, "A", "at.dasz.DocumentManagement");
            XmlStreamer.FromStream(ref this._A_pos, xml, "A_pos", "at.dasz.DocumentManagement");
            XmlStreamer.FromStream(ref this._fk_guid_B, xml, "B", "at.dasz.DocumentManagement");
            XmlStreamer.FromStream(ref this._B_pos, xml, "B_pos", "at.dasz.DocumentManagement");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Document_has_Blob_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Document_has_Blob_RelationEntryMemoryImpl)obj;
            var me = (Document_has_Blob_RelationEntryMemoryImpl)this;

            me.AIndex = other.AIndex;
            me.BIndex = other.BIndex;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (at.dasz.DocumentManagement.DocumentMemoryImpl)Context.FindPersistenceObject<at.dasz.DocumentManagement.Document>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (at.dasz.DocumentManagement.DocumentMemoryImpl)Context.Find<at.dasz.DocumentManagement.Document>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Kistl.App.Base.BlobMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.Blob>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Base.BlobMemoryImpl)Context.Find<Kistl.App.Base.Blob>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.Base
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Identity_memberOf_Group_RelationEntryMemoryImpl")]
    public class Identity_memberOf_Group_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.Base.Identity, Kistl.App.Base.IdentityMemoryImpl, Kistl.App.Base.Group, Kistl.App.Base.GroupMemoryImpl>, Identity_memberOf_Group_RelationEntry
    {
        [Obsolete]
        public Identity_memberOf_Group_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public Identity_memberOf_Group_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("3efb7ae8-ba6b-40e3-9482-b45d1c101743");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.Base.Identity)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Base.Group)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.Base.Identity; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.Identity A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.Base.IdentityMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.IdentityMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.IdentityMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.Base.IdentityMemoryImpl)Context.Find<Kistl.App.Base.Identity>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Base.Group; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.Group B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Base.GroupMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.GroupMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.GroupMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Base.GroupMemoryImpl)Context.Find<Kistl.App.Base.Group>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.Base");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.Base");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.Base");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Identity_memberOf_Group_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Identity_memberOf_Group_RelationEntryMemoryImpl)obj;
            var me = (Identity_memberOf_Group_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                AImpl = (Kistl.App.Base.IdentityMemoryImpl)Context.Find<Kistl.App.Base.Identity>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Base.GroupMemoryImpl)Context.Find<Kistl.App.Base.Group>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.Base
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("IndexConstraint_ensures_unique_on_Property_RelationEntryMemoryImpl")]
    public class IndexConstraint_ensures_unique_on_Property_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.Base.IndexConstraint, Kistl.App.Base.IndexConstraintMemoryImpl, Kistl.App.Base.Property, Kistl.App.Base.PropertyMemoryImpl>, IndexConstraint_ensures_unique_on_Property_RelationEntry, Kistl.API.IExportableInternal, Kistl.App.Base.IExportable
    {
        [Obsolete]
        public IndexConstraint_ensures_unique_on_Property_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public IndexConstraint_ensures_unique_on_Property_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        // BEGIN Kistl.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(Guid);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                }
            }
        }
        private Guid _ExportGuid;
        // END Kistl.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("29235ba6-5979-4ed8-8e75-6bd0837c7f28");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.Base.IndexConstraint)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Base.Property)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.Base.IndexConstraint; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.IndexConstraint A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.Base.IndexConstraintMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;

        private Guid? _fk_guid_A = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.IndexConstraintMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.IndexConstraintMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.Base.IndexConstraintMemoryImpl)Context.Find<Kistl.App.Base.IndexConstraint>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Base.Property; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.Property B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Base.PropertyMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;

        private Guid? _fk_guid_B = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.PropertyMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.PropertyMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Base.PropertyMemoryImpl)Context.Find<Kistl.App.Base.Property>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._ExportGuid, binStream);
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._ExportGuid, binStream);
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.Base");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.Base");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.Base");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Kistl.App.Base");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Kistl.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_guid_A, xml, "A", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._fk_guid_B, xml, "B", "Kistl.App.Base");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(IndexConstraint_ensures_unique_on_Property_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (IndexConstraint_ensures_unique_on_Property_RelationEntryMemoryImpl)obj;
            var me = (IndexConstraint_ensures_unique_on_Property_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Kistl.App.Base.IndexConstraintMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.IndexConstraint>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Kistl.App.Base.IndexConstraintMemoryImpl)Context.Find<Kistl.App.Base.IndexConstraint>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Kistl.App.Base.PropertyMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.Property>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Base.PropertyMemoryImpl)Context.Find<Kistl.App.Base.Property>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.Test
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Muhblah_has_TestCustomObject_RelationEntryMemoryImpl")]
    public class Muhblah_has_TestCustomObject_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.Test.Muhblah, Kistl.App.Test.MuhblahMemoryImpl, Kistl.App.Test.TestCustomObject, Kistl.App.Test.TestCustomObjectMemoryImpl>, Muhblah_has_TestCustomObject_RelationEntry
    {
        [Obsolete]
        public Muhblah_has_TestCustomObject_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public Muhblah_has_TestCustomObject_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("d1e0da3e-ce64-4587-b62d-70c0f4371d97");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.Test.Muhblah)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Test.TestCustomObject)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.Test.Muhblah; moduleNamespace=Kistl.App.Test;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Test.Muhblah A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.Test.MuhblahMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Test.MuhblahMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Test.MuhblahMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.Test.MuhblahMemoryImpl)Context.Find<Kistl.App.Test.Muhblah>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Test.TestCustomObject; moduleNamespace=Kistl.App.Test;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Test.TestCustomObject B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Test.TestCustomObjectMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Test.TestCustomObjectMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Test.TestCustomObjectMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Test.TestCustomObjectMemoryImpl)Context.Find<Kistl.App.Test.TestCustomObject>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.Test");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.Test");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.Test");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.Test");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Muhblah_has_TestCustomObject_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Muhblah_has_TestCustomObject_RelationEntryMemoryImpl)obj;
            var me = (Muhblah_has_TestCustomObject_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                AImpl = (Kistl.App.Test.MuhblahMemoryImpl)Context.Find<Kistl.App.Test.Muhblah>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Test.TestCustomObjectMemoryImpl)Context.Find<Kistl.App.Test.TestCustomObject>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.Test
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("N_to_M_relations_A_connectsTo_N_to_M_relations_B_RelationEntryMemoryImpl")]
    public class N_to_M_relations_A_connectsTo_N_to_M_relations_B_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.Test.N_to_M_relations_A, Kistl.App.Test.N_to_M_relations_AMemoryImpl, Kistl.App.Test.N_to_M_relations_B, Kistl.App.Test.N_to_M_relations_BMemoryImpl>, N_to_M_relations_A_connectsTo_N_to_M_relations_B_RelationEntry
    {
        [Obsolete]
        public N_to_M_relations_A_connectsTo_N_to_M_relations_B_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public N_to_M_relations_A_connectsTo_N_to_M_relations_B_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("3555da6e-0e9b-4f7c-903e-a51f3cce7cd9");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.Test.N_to_M_relations_A)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Test.N_to_M_relations_B)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.Test.N_to_M_relations_A; moduleNamespace=Kistl.App.Test;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Test.N_to_M_relations_A A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.Test.N_to_M_relations_AMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Test.N_to_M_relations_AMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Test.N_to_M_relations_AMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.Test.N_to_M_relations_AMemoryImpl)Context.Find<Kistl.App.Test.N_to_M_relations_A>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Test.N_to_M_relations_B; moduleNamespace=Kistl.App.Test;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Test.N_to_M_relations_B B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Test.N_to_M_relations_BMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Test.N_to_M_relations_BMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Test.N_to_M_relations_BMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Test.N_to_M_relations_BMemoryImpl)Context.Find<Kistl.App.Test.N_to_M_relations_B>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.Test");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.Test");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.Test");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.Test");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(N_to_M_relations_A_connectsTo_N_to_M_relations_B_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (N_to_M_relations_A_connectsTo_N_to_M_relations_B_RelationEntryMemoryImpl)obj;
            var me = (N_to_M_relations_A_connectsTo_N_to_M_relations_B_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                AImpl = (Kistl.App.Test.N_to_M_relations_AMemoryImpl)Context.Find<Kistl.App.Test.N_to_M_relations_A>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Test.N_to_M_relations_BMemoryImpl)Context.Find<Kistl.App.Test.N_to_M_relations_B>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.GUI
{
	using Kistl.App.Base;
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("NavigationScreen_accessed_by_Group_RelationEntryMemoryImpl")]
    public class NavigationScreen_accessed_by_Group_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.GUI.NavigationScreen, Kistl.App.GUI.NavigationScreenMemoryImpl, Kistl.App.Base.Group, Kistl.App.Base.GroupMemoryImpl>, Kistl.API.IExportableInternal, Kistl.App.Base.IExportable, NavigationScreen_accessed_by_Group_RelationEntry
    {
        [Obsolete]
        public NavigationScreen_accessed_by_Group_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public NavigationScreen_accessed_by_Group_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        // BEGIN Kistl.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(Guid);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                }
            }
        }
        private Guid _ExportGuid;
        // END Kistl.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("b88c12ac-eabe-4aee-913e-5edd9d2a193a");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.GUI.NavigationScreen)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Base.Group)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.GUI.NavigationScreen; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.GUI.NavigationScreen A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.GUI.NavigationScreenMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;

        private Guid? _fk_guid_A = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.GUI.NavigationScreenMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.GUI.NavigationScreenMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.GUI.NavigationScreenMemoryImpl)Context.Find<Kistl.App.GUI.NavigationScreen>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Base.Group; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.Group B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Base.GroupMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;

        private Guid? _fk_guid_B = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.GroupMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.GroupMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Base.GroupMemoryImpl)Context.Find<Kistl.App.Base.Group>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._ExportGuid, binStream);
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._ExportGuid, binStream);
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.GUI");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.GUI");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.GUI");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.GUI");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("Kistl.App.GUI")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Kistl.App.GUI");
            if (modules.Contains("*") || modules.Contains("Kistl.App.GUI")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Kistl.App.GUI");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_guid_A, xml, "A", "Kistl.App.GUI");
            XmlStreamer.FromStream(ref this._fk_guid_B, xml, "B", "Kistl.App.GUI");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(NavigationScreen_accessed_by_Group_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (NavigationScreen_accessed_by_Group_RelationEntryMemoryImpl)obj;
            var me = (NavigationScreen_accessed_by_Group_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Kistl.App.GUI.NavigationScreenMemoryImpl)Context.FindPersistenceObject<Kistl.App.GUI.NavigationScreen>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Kistl.App.GUI.NavigationScreenMemoryImpl)Context.Find<Kistl.App.GUI.NavigationScreen>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Kistl.App.Base.GroupMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.Group>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Base.GroupMemoryImpl)Context.Find<Kistl.App.Base.Group>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.Base
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("ObjectClass_implements_Interface_RelationEntryMemoryImpl")]
    public class ObjectClass_implements_Interface_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.Base.ObjectClass, Kistl.App.Base.ObjectClassMemoryImpl, Kistl.App.Base.Interface, Kistl.App.Base.InterfaceMemoryImpl>, Kistl.API.IExportableInternal, Kistl.App.Base.IExportable, ObjectClass_implements_Interface_RelationEntry
    {
        [Obsolete]
        public ObjectClass_implements_Interface_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public ObjectClass_implements_Interface_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        // BEGIN Kistl.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(Guid);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                }
            }
        }
        private Guid _ExportGuid;
        // END Kistl.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("692c1064-37a2-4be3-a81e-4cb91f673aa3");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.Base.ObjectClass)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Base.Interface)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.Base.ObjectClass; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.ObjectClass A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.Base.ObjectClassMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;

        private Guid? _fk_guid_A = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.ObjectClassMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.ObjectClassMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.Base.ObjectClassMemoryImpl)Context.Find<Kistl.App.Base.ObjectClass>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Base.Interface; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.Interface B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Base.InterfaceMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;

        private Guid? _fk_guid_B = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.InterfaceMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.InterfaceMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Base.InterfaceMemoryImpl)Context.Find<Kistl.App.Base.Interface>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._ExportGuid, binStream);
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._ExportGuid, binStream);
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.Base");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.Base");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.Base");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Kistl.App.Base");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Kistl.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_guid_A, xml, "A", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._fk_guid_B, xml, "B", "Kistl.App.Base");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(ObjectClass_implements_Interface_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (ObjectClass_implements_Interface_RelationEntryMemoryImpl)obj;
            var me = (ObjectClass_implements_Interface_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Kistl.App.Base.ObjectClassMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.ObjectClass>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Kistl.App.Base.ObjectClassMemoryImpl)Context.Find<Kistl.App.Base.ObjectClass>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Kistl.App.Base.InterfaceMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.Interface>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Base.InterfaceMemoryImpl)Context.Find<Kistl.App.Base.Interface>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.Projekte
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Projekt_haben_Mitarbeiter_RelationEntryMemoryImpl")]
    public class Projekt_haben_Mitarbeiter_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.Projekte.Projekt, Kistl.App.Projekte.ProjektMemoryImpl, Kistl.App.Projekte.Mitarbeiter, Kistl.App.Projekte.MitarbeiterMemoryImpl>, Kistl.API.IExportableInternal, Kistl.App.Base.IExportable, Projekt_haben_Mitarbeiter_RelationEntry
    {
        [Obsolete]
        public Projekt_haben_Mitarbeiter_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public Projekt_haben_Mitarbeiter_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        // BEGIN Kistl.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(Guid);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                }
            }
        }
        private Guid _ExportGuid;
        // END Kistl.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("c7b3cf10-cdc8-454c-826c-04a0f7e5ef3e");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.Projekte.Projekt)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Projekte.Mitarbeiter)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.Projekte.Projekt; moduleNamespace=Kistl.App.Projekte;
        // inverse Navigator=none; is reference;
        // PositionStorage=A_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Projekte.Projekt A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.Projekte.ProjektMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;

        private Guid? _fk_guid_A = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Projekte.ProjektMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Projekte.ProjektMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.Projekte.ProjektMemoryImpl)Context.Find<Kistl.App.Projekte.Projekt>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // BEGIN Kistl.Generator.Templates.Properties.NotifyingValueProperty
        public int? A_pos
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int?);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _A_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_A_pos != value)
                {
                    var __oldValue = _A_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("A_pos", __oldValue, __newValue);
                    _A_pos = __newValue;
                    NotifyPropertyChanged("A_pos", __oldValue, __newValue);
                }
            }
        }
        private int? _A_pos;
        // END Kistl.Generator.Templates.Properties.NotifyingValueProperty
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Projekte.Mitarbeiter; moduleNamespace=Kistl.App.Projekte;
        // inverse Navigator=none; is reference;
        // PositionStorage=B_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Projekte.Mitarbeiter B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Projekte.MitarbeiterMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;

        private Guid? _fk_guid_B = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Projekte.MitarbeiterMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Projekte.MitarbeiterMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Projekte.MitarbeiterMemoryImpl)Context.Find<Kistl.App.Projekte.Mitarbeiter>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // BEGIN Kistl.Generator.Templates.Properties.NotifyingValueProperty
        public int? B_pos
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int?);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _B_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_B_pos != value)
                {
                    var __oldValue = _B_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("B_pos", __oldValue, __newValue);
                    _B_pos = __newValue;
                    NotifyPropertyChanged("B_pos", __oldValue, __newValue);
                }
            }
        }
        private int? _B_pos;
        // END Kistl.Generator.Templates.Properties.NotifyingValueProperty
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        /// <summary>
        /// Index into the A-side list of this relation
        /// </summary>
        public int? AIndex { get { return _A_pos; } set { _A_pos = value; } }

        /// <summary>
        /// Index into the B-side list of this relation
        /// </summary>
        public int? BIndex { get { return _B_pos; } set { _B_pos = value; } }

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._ExportGuid, binStream);
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(this._A_pos, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
            BinarySerializer.ToStream(this._B_pos, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._ExportGuid, binStream);
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._A_pos, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            BinarySerializer.FromStream(out this._B_pos, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.Projekte");
            XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "Kistl.App.Projekte");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.Projekte");
            XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "Kistl.App.Projekte");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.Projekte");
            XmlStreamer.FromStream(ref this._A_pos, xml, "A_pos", "Kistl.App.Projekte");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.Projekte");
            XmlStreamer.FromStream(ref this._B_pos, xml, "B_pos", "Kistl.App.Projekte");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("Kistl.App.Projekte")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Kistl.App.Projekte");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Projekte")) XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "Kistl.App.Projekte");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Projekte")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Kistl.App.Projekte");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Projekte")) XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "Kistl.App.Projekte");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_guid_A, xml, "A", "Kistl.App.Projekte");
            XmlStreamer.FromStream(ref this._A_pos, xml, "A_pos", "Kistl.App.Projekte");
            XmlStreamer.FromStream(ref this._fk_guid_B, xml, "B", "Kistl.App.Projekte");
            XmlStreamer.FromStream(ref this._B_pos, xml, "B_pos", "Kistl.App.Projekte");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Projekt_haben_Mitarbeiter_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Projekt_haben_Mitarbeiter_RelationEntryMemoryImpl)obj;
            var me = (Projekt_haben_Mitarbeiter_RelationEntryMemoryImpl)this;

            me.AIndex = other.AIndex;
            me.BIndex = other.BIndex;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Kistl.App.Projekte.ProjektMemoryImpl)Context.FindPersistenceObject<Kistl.App.Projekte.Projekt>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Kistl.App.Projekte.ProjektMemoryImpl)Context.Find<Kistl.App.Projekte.Projekt>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Kistl.App.Projekte.MitarbeiterMemoryImpl)Context.FindPersistenceObject<Kistl.App.Projekte.Mitarbeiter>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Projekte.MitarbeiterMemoryImpl)Context.Find<Kistl.App.Projekte.Mitarbeiter>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.Base
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("RoleMembership_resolves_Relation_RelationEntryMemoryImpl")]
    public class RoleMembership_resolves_Relation_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.Base.RoleMembership, Kistl.App.Base.RoleMembershipMemoryImpl, Kistl.App.Base.Relation, Kistl.App.Base.RelationMemoryImpl>, Kistl.API.IExportableInternal, Kistl.App.Base.IExportable, RoleMembership_resolves_Relation_RelationEntry
    {
        [Obsolete]
        public RoleMembership_resolves_Relation_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public RoleMembership_resolves_Relation_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        // BEGIN Kistl.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(Guid);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                }
            }
        }
        private Guid _ExportGuid;
        // END Kistl.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("f74d425f-e733-4cba-baca-f4a05fbc0a80");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.Base.RoleMembership)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Base.Relation)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.Base.RoleMembership; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=A_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.RoleMembership A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.Base.RoleMembershipMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;

        private Guid? _fk_guid_A = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.RoleMembershipMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.RoleMembershipMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.Base.RoleMembershipMemoryImpl)Context.Find<Kistl.App.Base.RoleMembership>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // BEGIN Kistl.Generator.Templates.Properties.NotifyingValueProperty
        public int? A_pos
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int?);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _A_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_A_pos != value)
                {
                    var __oldValue = _A_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("A_pos", __oldValue, __newValue);
                    _A_pos = __newValue;
                    NotifyPropertyChanged("A_pos", __oldValue, __newValue);
                }
            }
        }
        private int? _A_pos;
        // END Kistl.Generator.Templates.Properties.NotifyingValueProperty
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Base.Relation; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=B_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.Relation B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Base.RelationMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;

        private Guid? _fk_guid_B = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.RelationMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.RelationMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Base.RelationMemoryImpl)Context.Find<Kistl.App.Base.Relation>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // BEGIN Kistl.Generator.Templates.Properties.NotifyingValueProperty
        public int? B_pos
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int?);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _B_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_B_pos != value)
                {
                    var __oldValue = _B_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("B_pos", __oldValue, __newValue);
                    _B_pos = __newValue;
                    NotifyPropertyChanged("B_pos", __oldValue, __newValue);
                }
            }
        }
        private int? _B_pos;
        // END Kistl.Generator.Templates.Properties.NotifyingValueProperty
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        /// <summary>
        /// Index into the A-side list of this relation
        /// </summary>
        public int? AIndex { get { return _A_pos; } set { _A_pos = value; } }

        /// <summary>
        /// Index into the B-side list of this relation
        /// </summary>
        public int? BIndex { get { return _B_pos; } set { _B_pos = value; } }

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._ExportGuid, binStream);
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(this._A_pos, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
            BinarySerializer.ToStream(this._B_pos, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._ExportGuid, binStream);
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._A_pos, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            BinarySerializer.FromStream(out this._B_pos, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.Base");
            XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "Kistl.App.Base");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.Base");
            XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "Kistl.App.Base");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._A_pos, xml, "A_pos", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._B_pos, xml, "B_pos", "Kistl.App.Base");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Kistl.App.Base");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "Kistl.App.Base");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Kistl.App.Base");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "Kistl.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_guid_A, xml, "A", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._A_pos, xml, "A_pos", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._fk_guid_B, xml, "B", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._B_pos, xml, "B_pos", "Kistl.App.Base");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(RoleMembership_resolves_Relation_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (RoleMembership_resolves_Relation_RelationEntryMemoryImpl)obj;
            var me = (RoleMembership_resolves_Relation_RelationEntryMemoryImpl)this;

            me.AIndex = other.AIndex;
            me.BIndex = other.BIndex;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Kistl.App.Base.RoleMembershipMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.RoleMembership>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Kistl.App.Base.RoleMembershipMemoryImpl)Context.Find<Kistl.App.Base.RoleMembership>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Kistl.App.Base.RelationMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.Relation>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Base.RelationMemoryImpl)Context.Find<Kistl.App.Base.Relation>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace ZBox.App.SchemaMigration
{
	using Kistl.App.Base;
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("SourceColumn_created_Property_RelationEntryMemoryImpl")]
    public class SourceColumn_created_Property_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<ZBox.App.SchemaMigration.SourceColumn, ZBox.App.SchemaMigration.SourceColumnMemoryImpl, Kistl.App.Base.Property, Kistl.App.Base.PropertyMemoryImpl>, Kistl.API.IExportableInternal, Kistl.App.Base.IExportable, SourceColumn_created_Property_RelationEntry
    {
        [Obsolete]
        public SourceColumn_created_Property_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public SourceColumn_created_Property_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        // BEGIN Kistl.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(Guid);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                }
            }
        }
        private Guid _ExportGuid;
        // END Kistl.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("fb27e3f8-3615-4f3b-ae2a-2b89b8782e27");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (ZBox.App.SchemaMigration.SourceColumn)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Base.Property)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=ZBox.App.SchemaMigration.SourceColumn; moduleNamespace=ZBox.App.SchemaMigration;
        // inverse Navigator=none; is reference;
        // PositionStorage=A_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public ZBox.App.SchemaMigration.SourceColumn A
        {
            get { return AImpl; }
            set { AImpl = (ZBox.App.SchemaMigration.SourceColumnMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;

        private Guid? _fk_guid_A = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal ZBox.App.SchemaMigration.SourceColumnMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                ZBox.App.SchemaMigration.SourceColumnMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (ZBox.App.SchemaMigration.SourceColumnMemoryImpl)Context.Find<ZBox.App.SchemaMigration.SourceColumn>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // BEGIN Kistl.Generator.Templates.Properties.NotifyingValueProperty
        public int? A_pos
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int?);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _A_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_A_pos != value)
                {
                    var __oldValue = _A_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("A_pos", __oldValue, __newValue);
                    _A_pos = __newValue;
                    NotifyPropertyChanged("A_pos", __oldValue, __newValue);
                }
            }
        }
        private int? _A_pos;
        // END Kistl.Generator.Templates.Properties.NotifyingValueProperty
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Base.Property; moduleNamespace=ZBox.App.SchemaMigration;
        // inverse Navigator=none; is reference;
        // PositionStorage=B_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.Property B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Base.PropertyMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;

        private Guid? _fk_guid_B = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.PropertyMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.PropertyMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Base.PropertyMemoryImpl)Context.Find<Kistl.App.Base.Property>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // BEGIN Kistl.Generator.Templates.Properties.NotifyingValueProperty
        public int? B_pos
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int?);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _B_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_B_pos != value)
                {
                    var __oldValue = _B_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("B_pos", __oldValue, __newValue);
                    _B_pos = __newValue;
                    NotifyPropertyChanged("B_pos", __oldValue, __newValue);
                }
            }
        }
        private int? _B_pos;
        // END Kistl.Generator.Templates.Properties.NotifyingValueProperty
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        /// <summary>
        /// Index into the A-side list of this relation
        /// </summary>
        public int? AIndex { get { return _A_pos; } set { _A_pos = value; } }

        /// <summary>
        /// Index into the B-side list of this relation
        /// </summary>
        public int? BIndex { get { return _B_pos; } set { _B_pos = value; } }

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._ExportGuid, binStream);
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(this._A_pos, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
            BinarySerializer.ToStream(this._B_pos, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._ExportGuid, binStream);
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._A_pos, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            BinarySerializer.FromStream(out this._B_pos, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "ZBox.App.SchemaMigration");
            XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "ZBox.App.SchemaMigration");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "ZBox.App.SchemaMigration");
            XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "ZBox.App.SchemaMigration");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "ZBox.App.SchemaMigration");
            XmlStreamer.FromStream(ref this._A_pos, xml, "A_pos", "ZBox.App.SchemaMigration");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "ZBox.App.SchemaMigration");
            XmlStreamer.FromStream(ref this._B_pos, xml, "B_pos", "ZBox.App.SchemaMigration");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("ZBox.App.SchemaMigration")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "ZBox.App.SchemaMigration");
            if (modules.Contains("*") || modules.Contains("ZBox.App.SchemaMigration")) XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "ZBox.App.SchemaMigration");
            if (modules.Contains("*") || modules.Contains("ZBox.App.SchemaMigration")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "ZBox.App.SchemaMigration");
            if (modules.Contains("*") || modules.Contains("ZBox.App.SchemaMigration")) XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "ZBox.App.SchemaMigration");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_guid_A, xml, "A", "ZBox.App.SchemaMigration");
            XmlStreamer.FromStream(ref this._A_pos, xml, "A_pos", "ZBox.App.SchemaMigration");
            XmlStreamer.FromStream(ref this._fk_guid_B, xml, "B", "ZBox.App.SchemaMigration");
            XmlStreamer.FromStream(ref this._B_pos, xml, "B_pos", "ZBox.App.SchemaMigration");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(SourceColumn_created_Property_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (SourceColumn_created_Property_RelationEntryMemoryImpl)obj;
            var me = (SourceColumn_created_Property_RelationEntryMemoryImpl)this;

            me.AIndex = other.AIndex;
            me.BIndex = other.BIndex;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (ZBox.App.SchemaMigration.SourceColumnMemoryImpl)Context.FindPersistenceObject<ZBox.App.SchemaMigration.SourceColumn>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (ZBox.App.SchemaMigration.SourceColumnMemoryImpl)Context.Find<ZBox.App.SchemaMigration.SourceColumn>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Kistl.App.Base.PropertyMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.Property>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Base.PropertyMemoryImpl)Context.Find<Kistl.App.Base.Property>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.GUI
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Template_hasMenu_Visual_RelationEntryMemoryImpl")]
    public class Template_hasMenu_Visual_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.GUI.Template, Kistl.App.GUI.TemplateMemoryImpl, Kistl.App.GUI.Visual, Kistl.App.GUI.VisualMemoryImpl>, Template_hasMenu_Visual_RelationEntry
    {
        [Obsolete]
        public Template_hasMenu_Visual_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public Template_hasMenu_Visual_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("81ff3089-57da-478c-8be5-fd23abc222a2");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.GUI.Template)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.GUI.Visual)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.GUI.Template; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.GUI.Template A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.GUI.TemplateMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.GUI.TemplateMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.GUI.TemplateMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.GUI.TemplateMemoryImpl)Context.Find<Kistl.App.GUI.Template>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.GUI.Visual; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.GUI.Visual B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.GUI.VisualMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.GUI.VisualMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.GUI.VisualMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.GUI.VisualMemoryImpl)Context.Find<Kistl.App.GUI.Visual>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.GUI");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.GUI");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.GUI");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.GUI");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Template_hasMenu_Visual_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Template_hasMenu_Visual_RelationEntryMemoryImpl)obj;
            var me = (Template_hasMenu_Visual_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                AImpl = (Kistl.App.GUI.TemplateMemoryImpl)Context.Find<Kistl.App.GUI.Template>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_B.HasValue)
                BImpl = (Kistl.App.GUI.VisualMemoryImpl)Context.Find<Kistl.App.GUI.Visual>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.Test
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("TestStudent_füllt_aus_Fragebogen_RelationEntryMemoryImpl")]
    public class TestStudent_füllt_aus_Fragebogen_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.Test.TestStudent, Kistl.App.Test.TestStudentMemoryImpl, Kistl.App.Test.Fragebogen, Kistl.App.Test.FragebogenMemoryImpl>, TestStudent_füllt_aus_Fragebogen_RelationEntry
    {
        [Obsolete]
        public TestStudent_füllt_aus_Fragebogen_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public TestStudent_füllt_aus_Fragebogen_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("6819ca86-571c-4d59-bc30-cc1fb0decc9e");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.Test.TestStudent)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Test.Fragebogen)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.Test.TestStudent; moduleNamespace=Kistl.App.Test;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Test.TestStudent A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.Test.TestStudentMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Test.TestStudentMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Test.TestStudentMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.Test.TestStudentMemoryImpl)Context.Find<Kistl.App.Test.TestStudent>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Test.Fragebogen; moduleNamespace=Kistl.App.Test;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Test.Fragebogen B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Test.FragebogenMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Test.FragebogenMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Test.FragebogenMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Test.FragebogenMemoryImpl)Context.Find<Kistl.App.Test.Fragebogen>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.Test");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.Test");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.Test");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.Test");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(TestStudent_füllt_aus_Fragebogen_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (TestStudent_füllt_aus_Fragebogen_RelationEntryMemoryImpl)obj;
            var me = (TestStudent_füllt_aus_Fragebogen_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                AImpl = (Kistl.App.Test.TestStudentMemoryImpl)Context.Find<Kistl.App.Test.TestStudent>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Test.FragebogenMemoryImpl)Context.Find<Kistl.App.Test.Fragebogen>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.Base
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("TypeRef_hasGenericArguments_TypeRef_RelationEntryMemoryImpl")]
    public class TypeRef_hasGenericArguments_TypeRef_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.Base.TypeRef, Kistl.App.Base.TypeRefMemoryImpl, Kistl.App.Base.TypeRef, Kistl.App.Base.TypeRefMemoryImpl>, Kistl.API.IExportableInternal, Kistl.App.Base.IExportable, TypeRef_hasGenericArguments_TypeRef_RelationEntry
    {
        [Obsolete]
        public TypeRef_hasGenericArguments_TypeRef_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public TypeRef_hasGenericArguments_TypeRef_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        // BEGIN Kistl.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(Guid);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                }
            }
        }
        private Guid _ExportGuid;
        // END Kistl.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("8b41ffa4-8ffa-4d96-b4e5-708188045c71");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.Base.TypeRef)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Base.TypeRef)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.Base.TypeRef; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=A_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.TypeRef A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.Base.TypeRefMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;

        private Guid? _fk_guid_A = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.TypeRefMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.TypeRefMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.Base.TypeRefMemoryImpl)Context.Find<Kistl.App.Base.TypeRef>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // BEGIN Kistl.Generator.Templates.Properties.NotifyingValueProperty
        public int? A_pos
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int?);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _A_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_A_pos != value)
                {
                    var __oldValue = _A_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("A_pos", __oldValue, __newValue);
                    _A_pos = __newValue;
                    NotifyPropertyChanged("A_pos", __oldValue, __newValue);
                }
            }
        }
        private int? _A_pos;
        // END Kistl.Generator.Templates.Properties.NotifyingValueProperty
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Base.TypeRef; moduleNamespace=Kistl.App.Base;
        // inverse Navigator=none; is reference;
        // PositionStorage=B_pos;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.TypeRef B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Base.TypeRefMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;

        private Guid? _fk_guid_B = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.TypeRefMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.TypeRefMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Base.TypeRefMemoryImpl)Context.Find<Kistl.App.Base.TypeRef>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // BEGIN Kistl.Generator.Templates.Properties.NotifyingValueProperty
        public int? B_pos
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int?);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _B_pos;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_B_pos != value)
                {
                    var __oldValue = _B_pos;
                    var __newValue = value;
                    NotifyPropertyChanging("B_pos", __oldValue, __newValue);
                    _B_pos = __newValue;
                    NotifyPropertyChanged("B_pos", __oldValue, __newValue);
                }
            }
        }
        private int? _B_pos;
        // END Kistl.Generator.Templates.Properties.NotifyingValueProperty
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        /// <summary>
        /// Index into the A-side list of this relation
        /// </summary>
        public int? AIndex { get { return _A_pos; } set { _A_pos = value; } }

        /// <summary>
        /// Index into the B-side list of this relation
        /// </summary>
        public int? BIndex { get { return _B_pos; } set { _B_pos = value; } }

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._ExportGuid, binStream);
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(this._A_pos, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
            BinarySerializer.ToStream(this._B_pos, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._ExportGuid, binStream);
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._A_pos, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            BinarySerializer.FromStream(out this._B_pos, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.Base");
            XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "Kistl.App.Base");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.Base");
            XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "Kistl.App.Base");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._A_pos, xml, "A_pos", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._B_pos, xml, "B_pos", "Kistl.App.Base");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Kistl.App.Base");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(this._A_pos, xml, "A_pos", "Kistl.App.Base");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Kistl.App.Base");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Base")) XmlStreamer.ToStream(this._B_pos, xml, "B_pos", "Kistl.App.Base");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_guid_A, xml, "A", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._A_pos, xml, "A_pos", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._fk_guid_B, xml, "B", "Kistl.App.Base");
            XmlStreamer.FromStream(ref this._B_pos, xml, "B_pos", "Kistl.App.Base");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(TypeRef_hasGenericArguments_TypeRef_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (TypeRef_hasGenericArguments_TypeRef_RelationEntryMemoryImpl)obj;
            var me = (TypeRef_hasGenericArguments_TypeRef_RelationEntryMemoryImpl)this;

            me.AIndex = other.AIndex;
            me.BIndex = other.BIndex;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Kistl.App.Base.TypeRefMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.TypeRef>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Kistl.App.Base.TypeRefMemoryImpl)Context.Find<Kistl.App.Base.TypeRef>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Kistl.App.Base.TypeRefMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.TypeRef>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Base.TypeRefMemoryImpl)Context.Find<Kistl.App.Base.TypeRef>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.GUI
{
	using Kistl.App.Base;
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("ViewDescriptor_supports_TypeRef_RelationEntryMemoryImpl")]
    public class ViewDescriptor_supports_TypeRef_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.GUI.ViewDescriptor, Kistl.App.GUI.ViewDescriptorMemoryImpl, Kistl.App.Base.TypeRef, Kistl.App.Base.TypeRefMemoryImpl>, Kistl.API.IExportableInternal, Kistl.App.Base.IExportable, ViewDescriptor_supports_TypeRef_RelationEntry
    {
        [Obsolete]
        public ViewDescriptor_supports_TypeRef_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public ViewDescriptor_supports_TypeRef_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        // BEGIN Kistl.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(Guid);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                }
            }
        }
        private Guid _ExportGuid;
        // END Kistl.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("786dae2f-cb6e-454d-93fd-192541df928d");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.GUI.ViewDescriptor)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.Base.TypeRef)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.GUI.ViewDescriptor; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.GUI.ViewDescriptor A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.GUI.ViewDescriptorMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;

        private Guid? _fk_guid_A = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.GUI.ViewDescriptorMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.GUI.ViewDescriptorMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.GUI.ViewDescriptorMemoryImpl)Context.Find<Kistl.App.GUI.ViewDescriptor>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.Base.TypeRef; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Base.TypeRef B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.Base.TypeRefMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;

        private Guid? _fk_guid_B = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.Base.TypeRefMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.Base.TypeRefMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.Base.TypeRefMemoryImpl)Context.Find<Kistl.App.Base.TypeRef>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._ExportGuid, binStream);
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._ExportGuid, binStream);
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.GUI");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.GUI");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.GUI");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.GUI");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("Kistl.App.GUI")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Kistl.App.GUI");
            if (modules.Contains("*") || modules.Contains("Kistl.App.GUI")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Kistl.App.GUI");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_guid_A, xml, "A", "Kistl.App.GUI");
            XmlStreamer.FromStream(ref this._fk_guid_B, xml, "B", "Kistl.App.GUI");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(ViewDescriptor_supports_TypeRef_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (ViewDescriptor_supports_TypeRef_RelationEntryMemoryImpl)obj;
            var me = (ViewDescriptor_supports_TypeRef_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Kistl.App.GUI.ViewDescriptorMemoryImpl)Context.FindPersistenceObject<Kistl.App.GUI.ViewDescriptor>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Kistl.App.GUI.ViewDescriptorMemoryImpl)Context.Find<Kistl.App.GUI.ViewDescriptor>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Kistl.App.Base.TypeRefMemoryImpl)Context.FindPersistenceObject<Kistl.App.Base.TypeRef>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Kistl.App.Base.TypeRefMemoryImpl)Context.Find<Kistl.App.Base.TypeRef>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.GUI
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("ViewModelDescriptor_displayedBy_ControlKind_RelationEntryMemoryImpl")]
    public class ViewModelDescriptor_displayedBy_ControlKind_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.GUI.ViewModelDescriptor, Kistl.App.GUI.ViewModelDescriptorMemoryImpl, Kistl.App.GUI.ControlKind, Kistl.App.GUI.ControlKindMemoryImpl>, Kistl.API.IExportableInternal, Kistl.App.Base.IExportable, ViewModelDescriptor_displayedBy_ControlKind_RelationEntry
    {
        [Obsolete]
        public ViewModelDescriptor_displayedBy_ControlKind_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public ViewModelDescriptor_displayedBy_ControlKind_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        // BEGIN Kistl.Generator.Templates.Properties.ExportGuidProperty
        public Guid ExportGuid
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(Guid);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ExportGuid;
                if (_ExportGuid == Guid.Empty) {
                    __result = _ExportGuid = Guid.NewGuid();
                }
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ExportGuid != value)
                {
                    var __oldValue = _ExportGuid;
                    var __newValue = value;
                    NotifyPropertyChanging("ExportGuid", __oldValue, __newValue);
                    _ExportGuid = __newValue;
                    NotifyPropertyChanged("ExportGuid", __oldValue, __newValue);
                }
            }
        }
        private Guid _ExportGuid;
        // END Kistl.Generator.Templates.Properties.ExportGuidProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("5404456a-4527-4e40-a660-b4a5e96e4a47");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.GUI.ViewModelDescriptor)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.GUI.ControlKind)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.GUI.ViewModelDescriptor; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.GUI.ViewModelDescriptor A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.GUI.ViewModelDescriptorMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;

        private Guid? _fk_guid_A = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.GUI.ViewModelDescriptorMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.GUI.ViewModelDescriptorMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.GUI.ViewModelDescriptorMemoryImpl)Context.Find<Kistl.App.GUI.ViewModelDescriptor>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.GUI.ControlKind; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.GUI.ControlKind B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.GUI.ControlKindMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;

        private Guid? _fk_guid_B = null;

        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.GUI.ControlKindMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.GUI.ControlKindMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.GUI.ControlKindMemoryImpl)Context.Find<Kistl.App.GUI.ControlKind>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._ExportGuid, binStream);
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._ExportGuid, binStream);
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.GUI");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.GUI");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.GUI");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.GUI");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            xml.WriteAttributeString("ExportGuid", _ExportGuid.ToString());
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("Kistl.App.GUI")) XmlStreamer.ToStream(A != null ? A.ExportGuid : (Guid?)null, xml, "A", "Kistl.App.GUI");
            if (modules.Contains("*") || modules.Contains("Kistl.App.GUI")) XmlStreamer.ToStream(B != null ? B.ExportGuid : (Guid?)null, xml, "B", "Kistl.App.GUI");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._ExportGuid, xml, "ExportGuid", "");
            XmlStreamer.FromStream(ref this._fk_guid_A, xml, "A", "Kistl.App.GUI");
            XmlStreamer.FromStream(ref this._fk_guid_B, xml, "B", "Kistl.App.GUI");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(ViewModelDescriptor_displayedBy_ControlKind_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (ViewModelDescriptor_displayedBy_ControlKind_RelationEntryMemoryImpl)obj;
            var me = (ViewModelDescriptor_displayedBy_ControlKind_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_guid_A.HasValue)
                AImpl = (Kistl.App.GUI.ViewModelDescriptorMemoryImpl)Context.FindPersistenceObject<Kistl.App.GUI.ViewModelDescriptor>(_fk_guid_A.Value);
            else
            if (_fk_A.HasValue)
                AImpl = (Kistl.App.GUI.ViewModelDescriptorMemoryImpl)Context.Find<Kistl.App.GUI.ViewModelDescriptor>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_guid_B.HasValue)
                BImpl = (Kistl.App.GUI.ControlKindMemoryImpl)Context.FindPersistenceObject<Kistl.App.GUI.ControlKind>(_fk_guid_B.Value);
            else
            if (_fk_B.HasValue)
                BImpl = (Kistl.App.GUI.ControlKindMemoryImpl)Context.Find<Kistl.App.GUI.ControlKind>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.GUI
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Visual_contains_Visual_RelationEntryMemoryImpl")]
    public class Visual_contains_Visual_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.GUI.Visual, Kistl.App.GUI.VisualMemoryImpl, Kistl.App.GUI.Visual, Kistl.App.GUI.VisualMemoryImpl>, Visual_contains_Visual_RelationEntry
    {
        [Obsolete]
        public Visual_contains_Visual_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public Visual_contains_Visual_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("4d4e1ffd-f362-40e2-9fe1-0711ded83241");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.GUI.Visual)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.GUI.Visual)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.GUI.Visual; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.GUI.Visual A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.GUI.VisualMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.GUI.VisualMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.GUI.VisualMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.GUI.VisualMemoryImpl)Context.Find<Kistl.App.GUI.Visual>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.GUI.Visual; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.GUI.Visual B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.GUI.VisualMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.GUI.VisualMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.GUI.VisualMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.GUI.VisualMemoryImpl)Context.Find<Kistl.App.GUI.Visual>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.GUI");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.GUI");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.GUI");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.GUI");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Visual_contains_Visual_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Visual_contains_Visual_RelationEntryMemoryImpl)obj;
            var me = (Visual_contains_Visual_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                AImpl = (Kistl.App.GUI.VisualMemoryImpl)Context.Find<Kistl.App.GUI.Visual>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_B.HasValue)
                BImpl = (Kistl.App.GUI.VisualMemoryImpl)Context.Find<Kistl.App.GUI.Visual>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.GUI
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.RelationEntry
    [System.Diagnostics.DebuggerDisplay("Visual_hasContextMenu_Visual_RelationEntryMemoryImpl")]
    public class Visual_hasContextMenu_Visual_RelationEntryMemoryImpl : Kistl.DalProvider.Memory.RelationEntryMemoryImpl<Kistl.App.GUI.Visual, Kistl.App.GUI.VisualMemoryImpl, Kistl.App.GUI.Visual, Kistl.App.GUI.VisualMemoryImpl>, Visual_hasContextMenu_Visual_RelationEntry
    {
        [Obsolete]
        public Visual_hasContextMenu_Visual_RelationEntryMemoryImpl()
            : base(null)
        {
        }

        public Visual_hasContextMenu_Visual_RelationEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty
        #region RelationEntry.ApplyClassHeadTemplate

        private static readonly Guid _relationID = new Guid("358c14b9-fef5-495d-8d44-04e84186830e");
        public override Guid RelationID { get { return _relationID; } }

        IDataObject IRelationEntry.AObject
        {
            get
            {
                return A;
            }
            set
            {
                // settor will do checking for us
                A = (Kistl.App.GUI.Visual)value;
            }
        }

        IDataObject IRelationEntry.BObject
        {
            get
            {
                return B;
            }
            set
            {
                // settor will do checking for us
                B = (Kistl.App.GUI.Visual)value;
            }
        }

        #endregion // RelationEntry.ApplyClassHeadTemplate


        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A
        // fkBackingName=_fk_A; fkGuidBackingName=_fk_guid_A;
        // referencedInterface=Kistl.App.GUI.Visual; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.GUI.Visual A
        {
            get { return AImpl; }
            set { AImpl = (Kistl.App.GUI.VisualMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_A;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.GUI.VisualMemoryImpl AImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.GUI.VisualMemoryImpl __value;
                if (_fk_A.HasValue)
                    __value = (Kistl.App.GUI.VisualMemoryImpl)Context.Find<Kistl.App.GUI.Visual>(_fk_A.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_A == null)
                    return;
                else if (value != null && value.ID == _fk_A)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = AImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("A", __oldValue, __newValue);


                // next, set the local reference
                _fk_A = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("A", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for A

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B
        // fkBackingName=_fk_B; fkGuidBackingName=_fk_guid_B;
        // referencedInterface=Kistl.App.GUI.Visual; moduleNamespace=Kistl.App.GUI;
        // inverse Navigator=none; is reference;
        // PositionStorage=none;
        // Target not exportable; does not call events

        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.GUI.Visual B
        {
            get { return BImpl; }
            set { BImpl = (Kistl.App.GUI.VisualMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        private int? _fk_B;


        // internal implementation
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        internal Kistl.App.GUI.VisualMemoryImpl BImpl
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
                Kistl.App.GUI.VisualMemoryImpl __value;
                if (_fk_B.HasValue)
                    __value = (Kistl.App.GUI.VisualMemoryImpl)Context.Find<Kistl.App.GUI.Visual>(_fk_B.Value);
                else
                    __value = null;


                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (value != null && value.Context != this.Context) throw new WrongKistlContextException();

                // shortcut noops
                if (value == null && _fk_B == null)
                    return;
                else if (value != null && value.ID == _fk_B)
                    return;

                // cache old value to remove inverse references later
                var __oldValue = BImpl;
                var __newValue = value;

                // Changing Event fires before anything is touched
                NotifyPropertyChanging("B", __oldValue, __newValue);


                // next, set the local reference
                _fk_B = __newValue == null ? (int?)null : __newValue.ID;

                // everything is done. fire the Changed event
                NotifyPropertyChanged("B", __oldValue, __newValue);

            }
        }
        // END Kistl.Generator.Templates.Properties.ObjectReferencePropertyTemplate for B

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(A != null ? A.ID : (int?)null, binStream);
            BinarySerializer.ToStream(B != null ? B.ID : (int?)null, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._fk_A, binStream);
            BinarySerializer.FromStream(out this._fk_B, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(A != null ? A.ID : (int?)null, xml, "A", "Kistl.App.GUI");
            XmlStreamer.ToStream(B != null ? B.ID : (int?)null, xml, "B", "Kistl.App.GUI");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._fk_A, xml, "A", "Kistl.App.GUI");
            XmlStreamer.FromStream(ref this._fk_B, xml, "B", "Kistl.App.GUI");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Visual_hasContextMenu_Visual_RelationEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Visual_hasContextMenu_Visual_RelationEntryMemoryImpl)obj;
            var me = (Visual_hasContextMenu_Visual_RelationEntryMemoryImpl)this;

        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_A.HasValue)
                AImpl = (Kistl.App.GUI.VisualMemoryImpl)Context.Find<Kistl.App.GUI.Visual>(_fk_A.Value);
            else
                AImpl = null;

            if (_fk_B.HasValue)
                BImpl = (Kistl.App.GUI.VisualMemoryImpl)Context.Find<Kistl.App.GUI.Visual>(_fk_B.Value);
            else
                BImpl = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.RelationEntry
}

namespace Kistl.App.Projekte
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.ValueCollectionEntry
    [System.Diagnostics.DebuggerDisplay("Kunde_EMails_CollectionEntryMemoryImpl")]
    public class Kunde_EMails_CollectionEntryMemoryImpl : Kistl.DalProvider.Memory.ValueCollectionEntryMemoryImpl<Kistl.App.Projekte.Kunde, Kistl.App.Projekte.KundeMemoryImpl, string>, Kistl.API.IExportableValueCollectionEntryInternal, Kunde_EMails_CollectionEntry
    {
        [Obsolete]
        public Kunde_EMails_CollectionEntryMemoryImpl()
            : base(null)
        {
        }

        public Kunde_EMails_CollectionEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty

        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        public Kistl.App.Projekte.Kunde Parent
        {
            get
            {
                if (_ParentCache != null && _ParentCache.ID == _fk_Parent)
                    return _ParentCache;

                if (_fk_Parent.HasValue)
                    _ParentCache = this.Context.Find<Kistl.App.Projekte.Kunde>(_fk_Parent.Value);
                else
                    _ParentCache = null;

                return _ParentCache;
            }
            set
            {
                if (value == null && !_fk_Parent.HasValue)
                    return;
                if (value != null && _fk_Parent.HasValue && value.ID == _fk_Parent.Value)
                    return;

                _ParentCache = value;
                if (value != null)
                    fk_Parent = value.ID;
                else
                    fk_Parent = null;
            }
        }
        private Kistl.App.Projekte.Kunde _ParentCache;

        public int? fk_Parent
        {
            get
            {
                return _fk_Parent;
            }
            set
            {
                if (_fk_Parent != value)
                {
                    var __oldValue = _fk_Parent;
                    NotifyPropertyChanging("Parent", __oldValue, value);
                    _fk_Parent = value;
                    NotifyPropertyChanged("Parent", __oldValue, value);
                }
            }
        }

        // backing store for serialization
        private int? _fk_Parent;
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.API.IDataObject ParentObject
        {
            get { return Parent; }
            set { Parent = (Kistl.App.Projekte.KundeMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.NotifyingValueProperty
        public System.String Value
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(System.String);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _Value;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_Value != value)
                {
                    var __oldValue = _Value;
                    var __newValue = value;
                    NotifyPropertyChanging("Value", __oldValue, __newValue);
                    _Value = __newValue;
                    NotifyPropertyChanged("Value", __oldValue, __newValue);
                }
            }
        }
        private System.String _Value;
        // END Kistl.Generator.Templates.Properties.NotifyingValueProperty
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public object ValueObject
        {
            get { return Value; }
            set { Value = (System.String)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._fk_Parent, binStream);
            BinarySerializer.ToStream(this._Value, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._fk_Parent, binStream);
            BinarySerializer.FromStream(out this._Value, binStream);
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._fk_Parent, xml, "Parent", "Kistl.App.Projekte");
            XmlStreamer.ToStream(this._Value, xml, "Value", "Kistl.App.Projekte");
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._fk_Parent, xml, "Parent", "Kistl.App.Projekte");
            XmlStreamer.FromStream(ref this._Value, xml, "Value", "Kistl.App.Projekte");
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public virtual void Export(System.Xml.XmlWriter xml, string[] modules)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            if (modules.Contains("*") || modules.Contains("Kistl.App.Projekte")) XmlStreamer.ToStream(this._fk_Parent, xml, "Parent", "Kistl.App.Projekte");
            if (modules.Contains("*") || modules.Contains("Kistl.App.Projekte")) XmlStreamer.ToStream(this._Value, xml, "Value", "Kistl.App.Projekte");
        }

        public virtual void MergeImport(System.Xml.XmlReader xml)
        {
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.FromStream(ref this._fk_Parent, xml, "Parent", "Kistl.App.Projekte");
            XmlStreamer.FromStream(ref this._Value, xml, "Value", "Kistl.App.Projekte");
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(Kunde_EMails_CollectionEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (Kunde_EMails_CollectionEntryMemoryImpl)obj;
            var me = (Kunde_EMails_CollectionEntryMemoryImpl)this;

            me._fk_Parent = other._fk_Parent;
            me.Value = other.Value;
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_Parent.HasValue)
                Parent = (Kistl.App.Projekte.KundeMemoryImpl)Context.Find<Kistl.App.Projekte.Kunde>(_fk_Parent.Value);
            else
                Parent = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.ValueCollectionEntry
}

namespace Kistl.App.Test
{
    // BEGIN Kistl.Generator.Templates.CollectionEntries.ValueCollectionEntry
    [System.Diagnostics.DebuggerDisplay("TestCustomObject_PhoneNumbersOther_CollectionEntryMemoryImpl")]
    public class TestCustomObject_PhoneNumbersOther_CollectionEntryMemoryImpl : Kistl.DalProvider.Memory.CompoundCollectionEntryMemoryImpl<Kistl.App.Test.TestCustomObject, Kistl.App.Test.TestCustomObjectMemoryImpl, Kistl.App.Test.TestPhoneCompoundObject, Kistl.App.Test.TestPhoneCompoundObjectMemoryImpl>, TestCustomObject_PhoneNumbersOther_CollectionEntry
    {
        [Obsolete]
        public TestCustomObject_PhoneNumbersOther_CollectionEntryMemoryImpl()
            : base(null)
        {
        }

        public TestCustomObject_PhoneNumbersOther_CollectionEntryMemoryImpl(Func<IFrozenContext> lazyCtx)
            : base(lazyCtx)
        {
        }
        // BEGIN Kistl.Generator.Templates.Properties.IdProperty
        public override int ID
        {
            get
            {
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return default(int);
                // create local variable to create single point of return
                // for the benefit of down-stream templates
                var __result = _ID;
                return __result;
            }
            set
            {
                if (this.IsReadonly) throw new ReadOnlyObjectException();
                if (_ID != value)
                {
                    var __oldValue = _ID;
                    var __newValue = value;
                    NotifyPropertyChanging("ID", __oldValue, __newValue);
                    _ID = __newValue;
                    NotifyPropertyChanged("ID", __oldValue, __newValue);
                }
            }
        }
        private int _ID;
        // END Kistl.Generator.Templates.Properties.IdProperty

        /// <summary>
        /// the A-side value of this CollectionEntry
        /// </summary>
        public Kistl.App.Test.TestCustomObject Parent
        {
            get
            {
                if (_ParentCache != null && _ParentCache.ID == _fk_Parent)
                    return _ParentCache;

                if (_fk_Parent.HasValue)
                    _ParentCache = this.Context.Find<Kistl.App.Test.TestCustomObject>(_fk_Parent.Value);
                else
                    _ParentCache = null;

                return _ParentCache;
            }
            set
            {
                if (value == null && !_fk_Parent.HasValue)
                    return;
                if (value != null && _fk_Parent.HasValue && value.ID == _fk_Parent.Value)
                    return;

                _ParentCache = value;
                if (value != null)
                    fk_Parent = value.ID;
                else
                    fk_Parent = null;
            }
        }
        private Kistl.App.Test.TestCustomObject _ParentCache;

        public int? fk_Parent
        {
            get
            {
                return _fk_Parent;
            }
            set
            {
                if (_fk_Parent != value)
                {
                    var __oldValue = _fk_Parent;
                    NotifyPropertyChanging("Parent", __oldValue, value);
                    _fk_Parent = value;
                    NotifyPropertyChanged("Parent", __oldValue, value);
                }
            }
        }

        // backing store for serialization
        private int? _fk_Parent;
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.API.IDataObject ParentObject
        {
            get { return Parent; }
            set { Parent = (Kistl.App.Test.TestCustomObjectMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        /// <summary>
        /// the B-side value of this CollectionEntry
        /// </summary>
        // BEGIN Kistl.Generator.Templates.Properties.CompoundObjectPropertyTemplate
        // implement the user-visible interface
        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public Kistl.App.Test.TestPhoneCompoundObject Value
        {
            get { return ValueImpl; }
            set { ValueImpl = (Kistl.App.Test.TestPhoneCompoundObjectMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        /// <summary>backing store for Value</summary>
        private Kistl.App.Test.TestPhoneCompoundObjectMemoryImpl _Value;

        /// <summary>backing property for Value, takes care of attaching/detaching the values</summary>
        public Kistl.App.Test.TestPhoneCompoundObjectMemoryImpl ValueImpl
        {
            get 
			{ 
                if (CurrentAccessRights == Kistl.API.AccessRights.None) return null;
				return _Value; 
			}
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if (!object.Equals(_Value, value))
                {
					var __oldValue = _Value;
					var __newValue = value;

					NotifyPropertyChanging("Value", __oldValue, __newValue);

					if (_Value != null)
					{ 
						_Value.DetachFromObject(this, "Value");
					}
					if (__newValue == null)
					{
						_Value = null;
					}
                    else
                    {
					    __newValue = (Kistl.App.Test.TestPhoneCompoundObjectMemoryImpl)__newValue.Clone();
					    _Value = __newValue;
					    _Value.AttachToObject(this, "Value");
                    }

					NotifyPropertyChanged("Value", __oldValue, __newValue);
				}
            }
        }
        // END Kistl.Generator.Templates.Properties.CompoundObjectPropertyTemplate        // BEGIN Kistl.Generator.Templates.Properties.DelegatingProperty
        public object ValueObject
        {
            get { return Value; }
            set { Value = (Kistl.App.Test.TestPhoneCompoundObjectMemoryImpl)value; }
        }
        // END Kistl.Generator.Templates.Properties.DelegatingProperty

        #region Serializer


        public override void ToStream(System.IO.BinaryWriter binStream, HashSet<IStreamable> auxObjects, bool eagerLoadLists)
        {
            base.ToStream(binStream, auxObjects, eagerLoadLists);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            BinarySerializer.ToStream(this._fk_Parent, binStream);
			BinarySerializer.ToStream(this.Value, binStream);
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.IO.BinaryReader binStream)
        {
            var baseResult = base.FromStream(binStream);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            BinarySerializer.FromStream(out this._fk_Parent, binStream);
			{
                // use backing store to avoid notifications
				Kistl.App.Test.TestPhoneCompoundObjectMemoryImpl tmp;
				BinarySerializer.FromStream(out tmp, binStream);
	            this.ValueImpl = tmp;
                if (this.ValueImpl != null)
                    this.ValueImpl.AttachToObject(this, "Value");
	        }
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        public override void ToStream(System.Xml.XmlWriter xml)
        {
            base.ToStream(xml);
            if (CurrentAccessRights == Kistl.API.AccessRights.None) return;
            XmlStreamer.ToStream(this._fk_Parent, xml, "Parent", "Kistl.App.Test");
			// TODO: Add XML Serializer here
        }

        public override IEnumerable<IPersistenceObject> FromStream(System.Xml.XmlReader xml)
        {
            var baseResult = base.FromStream(xml);
            var result = new List<IPersistenceObject>();
            if (CurrentAccessRights != Kistl.API.AccessRights.None) {
            XmlStreamer.FromStream(ref this._fk_Parent, xml, "Parent", "Kistl.App.Test");
            // TODO: Add XML Serializer here
            } // if (CurrentAccessRights != Kistl.API.AccessRights.None)
			return baseResult == null
                ? result.Count == 0
                    ? null
                    : result
                : baseResult.Concat(result);
        }

        #endregion

        public override Type GetImplementedInterface()
        {
            return typeof(TestCustomObject_PhoneNumbersOther_CollectionEntry);
        }

        public override void ApplyChangesFrom(IPersistenceObject obj)
        {
            base.ApplyChangesFrom(obj);
            var other = (TestCustomObject_PhoneNumbersOther_CollectionEntryMemoryImpl)obj;
            var me = (TestCustomObject_PhoneNumbersOther_CollectionEntryMemoryImpl)this;

            me._fk_Parent = other._fk_Parent;
            if (me.Value == null && other.Value != null) {
                me.Value = (Kistl.App.Test.TestPhoneCompoundObject)other.Value.Clone();
            } else if (me.Value != null && other.Value == null) {
                me.Value = null;
            } else if (me.Value != null && other.Value != null) {
                me.Value.ApplyChangesFrom(other.Value);
            }
        }


        public override void ReloadReferences()
        {
            // Do not reload references if the current object has been deleted.
            // TODO: enable when MemoryContext uses MemoryDataObjects
            //if (this.ObjectState == DataObjectState.Deleted) return;

            if (_fk_Parent.HasValue)
                Parent = (Kistl.App.Test.TestCustomObjectMemoryImpl)Context.Find<Kistl.App.Test.TestCustomObject>(_fk_Parent.Value);
            else
                Parent = null;

        }

    }
    // END Kistl.Generator.Templates.CollectionEntries.ValueCollectionEntry
}
