// <autogenerated/>

namespace Kistl.Objects
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;
    using Autofac;
	using Kistl.API;
    using global::NHibernate;
    using global::NHibernate.Cfg;
    using Kistl.API.Configuration;
    using Kistl.API.Utils;
    using Kistl.App.Extensions;
    using Kistl.DalProvider.Base;
    using Kistl.DalProvider.NHibernate;

    public class NHibernateModule
        : Autofac.Module
    {
        protected override void Load(ContainerBuilder builder)
        {
            base.Load(builder);


            builder
                .Register<NHibernateImplementationTypeChecker>(
                    c => new NHibernateImplementationTypeChecker(
                        c.Resolve<Func<IEnumerable<IImplementationTypeChecker>>>()))
                .As<INHibernateImplementationTypeChecker>()
                .As<IImplementationTypeChecker>()
                .InstancePerDependency();
                
            builder
                .Register<NHibernateActionsManager>(
                    c => new NHibernateActionsManager(
                        c.Resolve<ILifetimeScope>(),
                        c.Resolve<IDeploymentRestrictor>()))
                .As<INHibernateActionsManager>()
                .InstancePerLifetimeScope();

            builder
                .Register<ISessionFactory>(
                    c => {
                        var kistlConfig = c.Resolve<KistlConfig>();
                        var result = new Configuration();
                        var connectionString = kistlConfig.Server.GetConnectionString(Kistl.API.Helper.KistlConnectionStringKey);
                        result.Properties["dialect"] = connectionString.DatabaseProvider;
                        result.Properties["connection.connection_string"] = connectionString.ConnectionString;
                        result.Properties["max_fetch_depth"] = "1"; // keep SQL statements small
#if DEBUG
                        // make debugging easier by removing reflection optimizations
                        result.Properties["use_reflection_optimizer"] = "false";
                        result.Properties["bytecode.provider"] = "null";
#endif

                        return result
                            .AddAssembly(typeof(NHibernateModule).Assembly)
                            .BuildSessionFactory();
                    })
                .SingleInstance();

            builder
                .Register<ISession>(
                    (c, p) =>
                    {
                        var result = c.Resolve<ISessionFactory>().OpenSession(c.Resolve<IInterceptor>());
                        Logging.Log.DebugFormat("Created ISession: {0}", result.GetHashCode());
                        return result;
                    })
                .OnRelease(s => Logging.Log.DebugFormat("Disposed ISession: {0}", s.GetHashCode()))
                // TODO: reconsider this configuration
                //       using IPD makes it safer, but requires passing the session manually
                //       on the other hand, the session should never escape the data context
                .InstancePerDependency();
        }
    }


    internal sealed class NHibernateImplementationTypeChecker
        : Kistl.API.BaseTypeChecker, INHibernateImplementationTypeChecker
    {
        public NHibernateImplementationTypeChecker(Func<IEnumerable<IImplementationTypeChecker>> implTypeCheckersFactory)
            : base(implTypeCheckersFactory)
        {
        }

        public bool IsImplementationType(Type type)
        {
            if (type == null) { throw new ArgumentNullException("type"); }

			var myAssembly = typeof(NHibernateImplementationTypeChecker).Assembly;

            // Allow all top-level types from the generated assembly
            if (type.Assembly == myAssembly && type.DeclaringType == null)
                return true;

            // Allow all generic types which have only implementation types as arguments
            if (type.IsGenericType)
                return type.GetGenericArguments().All(t => IsImplementationType(t));

            return false;
		}
	}

    // marker class to provide stable and correct assembly reference
    internal sealed class NHibernateActionsManager
        : BaseCustomActionsManager, INHibernateActionsManager
    {
        public NHibernateActionsManager(ILifetimeScope container, IDeploymentRestrictor restrictor)
            : base(container, restrictor, "NHibernateImpl")
        {
        }
    }
}
