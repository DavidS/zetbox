This chapter describes the various ways and pieces the Kistl system is
programmed and customized.

\section{Objects}

\subsection{ObjectClass}

\subsection{Relation}
\input{Relations}

\subsection{Additional Metadata}

The object model is intended to be very rich and provide the various
subsystems with meta data directly from the \emph{ObjectClass}.

This section describes the various pieces of this meta data.

\subsubsection{New related objects}

A \emph{CreateRelatedUseCase} describes the use case of creating a new
object related to the "current" instance. One such use case would be
e.\,g.~"create a new \emph{Relation} from the current ObjectClass."

Such use cases are described with \emph{CreateRelatedUseCase} objects:

\begin{CS}
interface CreateRelatedUseCase
{
	string Label;
	Method Action;
	Relation AffectedRelation; // optional
}
\end{CS}

The \emph{Action} will be called when the user requests an execution of
this use case. This method doesn't take any parameters and returns the
newly created object. The infrastructure on the client will cause the
returned object to be displayed to the user. The business logic should
already have filled out the property values according to the use case.
The name of the method should start with "Create".

If the optional \emph{AffectedRelation} is specified, one of its ends it
must match the \emph{ObjectClass} of the \emph{Method}. This relation
can then be used to identify controls in the UI where the action can be
placed.

\section{Modules}

\section{Structs}
Structs are compound objects. They do not behave like C\# structs. This section describes their behaviour.
\par
Lets say there is a \emph{PhoneNumber} Struct
\begin{CS}
struct PhoneNumber
{
	string CountryCode;
	string AreaCode;
	string Number;
	string Extension;
}
\end{CS}

A Person has two phone numbers:

\begin{CS}
class Person
{
	string Name;
	...
	PhoneNumber  Tel;
	PhoneNumber? Fax;
}
\end{CS}
\emph{Tel} is not nullabe, \emph{Fax} is nullable.

\subsection{Accessing Structs}

\begin{itemize}
	\item{If a struct property is not nullable then the content of the property is always a valid reference.}
	\item{If a struct property is  nullable then the content of the property may be null.}
	\item{Unlike in C\# a struct property does not return a copy of the struct in the getter.}
	\item{When a struct property is set the given struct will be copied.}
\end{itemize}

\begin{CS}
Person p;
string number;

number = p.Tel.Number;
number = p.Fax.Number; // Throws NullReferenceException if Fax is null

p.Tel.Number = "12345678";
p.Fax.Number = "12345678"; // Throws NullReferenceException if Fax is null

PhoneNumber n;

n = p.Tel; // Does not create a copy
n.Number = "87654321"; // changes p.Tel.Number
n = p.Fax; // May be null
n.Number = "87654321"; // changes p.Fax.Number or throws NullReferenceException if Fax is null

p.Fax = p.Tel; // Creates a copy of p.Tel
p.Fax.Number = "87654321"; // does not change p.Tel.Number

p.Tel = null; // Throws a ArgumentNullException
p.Fax = null; // Sets Fax to null

n = ctx.CreateStruct<PhoneNumber>(); // Creates a new PhoneNumber Struct;
n.Number = "12345678";
p.Tel = n; // Creates a copy of n
p.Tel.Number = "18273645"; // does not change n.Number
n.Number = "87654321"; // does not change p.Tel.Number
\end{CS}


\section{Enhancing Kistl's inner workings}

\subsection{Database Providers}

\section{Graphical User Interface}

Like other subsystems, the GUI core is designed to be platform
independent. Therefore only the "outermost" shell contains toolkit
specific code.

\subsection{Architecture}

The GUI is modeled after the Model-View-ViewModel architecture. The
\emph{Model} represents the underlying data structures and business
logic. It is provided by the generated classes from the actual
datamodel. \emph{View Models} or \emph{presentable} models provide
display specific functionality like formatting, transient state holding
and implementing the user's possible actions. They always inherit from
\emph{Kistl.Client.Presentables.PresentableModel}.
Common implementations reside in the
\emph{Kistl.Client.Presentables} namespace. Finally,
\emph{Views} (editors and displays) are the actual components taking
care of showing content to the user and converting the users keypresses
and clicks into calls on the view models interface.  Views are
toolkit\footnote{Toolkits are GUI libraries like WPF, GTK\# or Windows
Forms but can also be implemented by more complex providers such as
ASP.NET.} specific and reside in the toolkit's respective assembly.

This architecture decouples the actual functionality of the Model and
the View Model completly from the inner workings of a toolkit and
thereby maximise the reuse of code between different clients.

\subsection{Plumbing}

The three layers are connected through two sets of descriptors. The
\emph{PresentableModelDescriptor}s contain information about the
available View Models and their preferred way of being displayed. The
\emph{ViewDescriptor}s link \emph{PresentableModelDescriptor}s with
the controls capable of displaying them.

\subsubsection{Presentable Model Descriptors}

Currently there exist three major types of View Models. 

\begin{description}

\item[\emph{DataObjectModel}s]{represent a complete data object;
provide standardised access to properties; provide non-standard Views
with additional functionality; selected via
\emph{ObjectClass.DefaultPresentableModelDescriptor}}

\item[\emph{ValueModel}s]{represent a specific piece of data;
representations of Properties are selected via
\emph{Property.ValueModelDescriptor}; method results are currently
created directly via \emph{Factory.CreateSpecificModel}}

\item[other Presentables]{represent objects in the View which do not
have persistent representations, like dialogs or wizards; always
created by calling \emph{Factory.CreateSpecificModel}}

\end{description} 

\subsubsection{View Descriptors}

These descriptors list the available Views by Toolkit and which subset
of Presentables they are able to work with.

\subsubsection{Control Kind}

The \emph{ControlKind} specifies the toolkit-independent kind or type of
control that should display a given Presentable. While the View
specifies the Control Kind it implements the Presentable requests a
specific Kind to be displayed via the
\emph{PresentableModelDescriptor.DefaultControlKind} value.

In special situations this default value can be overridden. For example,
the metadata of a property contains a \emph{RequestedControlKind} which
is used instead of the \emph{DefaultControlKind} when present. If there
is no View matching the requested Kind, the infrastructure may either
fall back to the default control kind, or use a similar control kind
from higher up in the hierarchy.

Typical kinds of controls:

\begin{description}

\item[WorkspaceWindow] {the top-level control within which all user
interaction happens}

\item[SelectionTaskDialog] {a dialog letting the user select something
from a longer list of items}

\item[ObjectView] {display the modeled object in full}

\item[ObjectListEntry] {display the modeled object as item in a list}

\item[TextEntry] {lets the user edit a property as text}

\item[IntegerSlider] {lets the user edit a number with a slider}

\item[YesNoCheckbox] {a simple yes/no checkbox}

\item[YesNoOtherText] {radio buttons allowing one to select either "yes",
"no" or a TextEntry field}

\item[ExtendedYesNoCheckbox] {a checkbox with additional text as label}

\end{description}

The kind of a control is identified by the \emph{ControlKind}'s class. The
hierarchy between different kinds of controls is modeled with inheritance.

Control Kinds can also be used to configure the actual control. This
possibility should be used sparingly as a control should instead seek to
infer its configuration from the underlying Presentable. For example, an
integer slider control should lookup the minimal and maximal allowed
values in the underlying \emph{IntegerRangeConstraint} while an
ExtendedYesNoCheckbox has no other place to retrieve the new label.

\subsection{Asynchronous Loading}

\emph{Not yet implemented.}

To facilitate low-latency user interfaces, the ViewModels should implement a
thin proxy layer to delegate all potential blocking operations onto a worker
thread. To keep programming this layer easy, there are a few helper classes and
a few constraints on the available interface mechanisms as well as a consistent
contract over all compliant ViewModels.

There are only three ways to communicate over the \emph{thread gap}:
\begin{enumerate}
\item{accessing a property}
\item{calling a \emph{void} function (with not \emph{out} or \emph{ref} parameters)}
\item{having an \emph{EventHandler} called}
\end{enumerate}

All compliant ViewModels provide a \emph{IsLoading} property that signifies
whether any background processing is active. While this property is true, any
value read from a property may be stale and/or about to be replaced. Changes to
the visible value of a property are always reported via the
\emph{PropertyChanged} event from the \emph{INotifyPropertyChanged} interface.
This should suffice for enabling binding frameworks to show current values to
the user: When reading a value from a property, a cached value is returned
immediately and optionally a refresh is triggered, which in turn may cause a
PropertyChanged event a little bit later.

In the case of time-dependent values, the ViewModel has to take care
to establish a periodic refresh timer\footnote{Todo: such a timer should be
provided by the infrastructure for platform dependent refreshing} which
triggers PropertyChanged events when new values arrive.

Similarily, methods called on the ViewModel do not actually do their work
immediately, but delegate to the background worker thread. Results either show
up automatically through changed properties and the PropertyChanged event or
via specialized events.

\subsubsection{Thread Safety}

The ViewModel is designed to be accessed from a single UI thread. Due to the
low latency of the public interface, this should pose no problem. The ViewModel
internally takes care of all synchronization with the worker thread. Due to the
asynchronicity of the underlying data it is quite possible that the values of
properties change while a method on the UI thread is currently executing.

\subsubsection{Automatic Generation}

Due to the restricted set of operations allowed, the proxy can and should be
automatically generated, freeing the ViewModel from the intricacies of
synchronizing and delegating across thread boundaries. Special needs like
callback parameters and time-dependent values have to be communicated via
special Attributes.

\section{Core Kistl Development Environment}

\subsection{Preparing a clean local build}

First, it is necessary to have a clean build environment. Use
\emph{subst} to create a drive \emph{P:} where your checkout
resides in a directory called \emph{Kistl}.

The \emph{!FullReset.cmd} will bring the database and the bootstrapping
code up to the current \emph{Database.xml}'s content.

Now the environment is ready for programming.

\subsection{Merging local and remote changes}

When the subversion repository has changed the \emph{Database.xml} while
local changes were made to the schema, it is necessary to merge them
before comitting.

After fetching and merging the update from the subversion repository,
the local \emph{Database.xml} has changes which are not yet in the
database. Running \emph{!DeployAll.cmd} updadates the SQL-schema and
produces a new set of generated assemblies in the \emph{CodeGenPath}.
After testing that the merge was successful, use \emph{GetCodeGen.cmd}
to update the working directory with the newly generated bootstrapping
code.

Now the working directory is ready for check in.



