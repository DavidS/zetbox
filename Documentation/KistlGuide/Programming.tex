\chapter{Programming}

This chapter describes the various ways and pieces the Kistl system is
programmed and customized.

\section{Objects}

\section{Modules}

\section{Enhancing Kistl's inner workings}

\subsection{Database Providers}

\section{Graphical User Interface}

Like other subsystems, the GUI core is designed to be platform
independent. Therefore only the "outermost" shell contains toolkit
specific code.

\subsection{Architecture}

The GUI is modeled after the Model-View-ViewModel architecture. The
\emph{Model} represents the underlying data structures and business
logic. It is provided by the generated classes from the actual
datamodel. \emph{View Models} or \emph{presentable} models provide
display specific functionality like formatting, transient state holding
and implementing the user's possible actions. They always inherit from
\emph{Kistl.Client.Presentables.PresentableModel}.
Common implementations reside in the
\emph{Kistl.Client.Presentables} namespace. Finally,
\emph{Views} (editors and displays) are the actual components taking
care of showing content to the user and converting the users keypresses
and clicks into calls on the view models interface.  Views are
toolkit\footnote{Toolkits are GUI libraries like WPF, GTK\# or Windows
Forms but can also be implemented by more complex providers such as
ASP.NET.} specific and reside in the toolkit's respective assembly.

This architecture decouples the actual functionality of the Model and
the View Model completly from the inner workings of a toolkit and
thereby maximise the reuse of code between different clients.

\subsection{Plumbing}

The three layers are connected through two sets of descriptors. The
\emph{PresentableModelDescriptor}s contain information about the
available View Models and their preferred way of being displayed. The
\emph{ViewDescriptor}s link \emph{PresentableModelDescriptor}s with
the controls capable of displaying them.

\subsubsection{Presentable Model Descriptors}

Currently there exist three major types of View Models. 

\begin{description}

\item[\emph{DataObjectModel}s]{represent a complete data object;
provide standardised access to properties; provide non-standard Views
with additional functionality; selected via
\emph{ObjectClass.DefaultPresentableModelDescriptor}}

\item[\emph{ValueModel}s]{represent a specific piece of data;
representations of Properties are selected via
\emph{Property.ValueModelDescriptor}; method results are currently
created directly via \emph{Factory.CreateSpecificModel}}

\item[other Presentables]{represent objects in the View which do not
have persistent representations, like dialogs or wizards; always
created by calling \emph{Factory.CreateSpecificModel}}

\end{description} 

\subsubsection{View Descriptors}

These descriptors list the available Views by Toolkit and which subset
of Presentables they are able to work with.

\subsubsection{Control Kind}

The \emph{ControlKind} specifies the toolkit-independent kind or type of
control that should display a given Presentable. While the View
specifies the Control Kind it implements the Presentable requests a
specific Kind to be displayed via the
\emph{PresentableModelDescriptor.DefaultControlKind} value.

In special situations this default value can be overridden. For example,
the metadata of a property contains a \emph{RequestedControlKind} which
is used instead of the \emph{DefaultControlKind} when present. If there
is no View matching the requested Kind, the infrastructure may either
fall back to the default control kind, or use a similar control kind
from higher up in the hierarchy.

Typical kinds of controls:

\begin{description}

\item[WorkspaceWindow] {the top-level control within which all user
interaction happens}

\item[SelectionTaskDialog] {a dialog letting the user select something
from a longer list of items}

\item[ObjectView] {display the modeled object in full}

\item[ObjectListEntry] {display the modeled object as item in a list}

\item[TextEntry] {lets the user edit a property as text}

\item[IntegerSlider] {lets the user edit a number with a slider}

\item[YesNoCheckbox] {a simple yes/no checkbox}

\item[YesNoOtherText] {radio buttons allowing one to select either "yes",
"no" or a TextEntry field}

\item[ExtendedYesNoCheckbox] {a checkbox with additional text as label}

\end{description}

Control Kinds can also be used to configure the actual control. This
possibility should be used sparingly as a control should instead seek to
infer its configuration from the underlying Presentable. For example, an
integer slider control should lookup the minimal and maximal allowed
values in the underlying \emph{IntegerRangeConstraint} while an
ExtendedYesNoCheckbox has no other place to retrieve the new label.


\section{Core Kistl Development Environment}

\subsection{Preparing a clean local build}

%% TODO: Replace this with one shell script.
%% TODO: This description is buggy, as it currently only creates empty
%%       tables

First, it is necessary to have a clean build environment. Use
\emph{subst} to create a drive \emph{P:} where your subversion checkout
resides in a directory called \emph{Kistl}. Be sure to delete the
contents of your \emph{CodeGenPath}\footnote{Typically
\emph{C:$\backslash$temp$\backslash$KistlCodeGen}} as well as any old
artifacts from your working directory\footnote{Use e.g. TortoiseSVN's
"Show ignored files" option to find cruft}. Clean your database by
calling the \emph{!KillDatabase.cmd} in the project's root.

Now build the solution. This will create the necessary artifacts to
bootstrap the database.

The \emph{!CreateDatabase.cmd} will now use the freshly built server
executable to update the (empty) schema in the database to the current
\emph{Database.xml}.

Finally you can run \emph{!DeployAll.cmd} to generate the frozen and
client objects.

Now the environment is ready for programming.

\subsection{Merging local and remote changes}

When the subversion repository has changed the \emph{Database.xml} while
local changes were made to the schema, it is necessary to merge them
before comitting.

After fetching and merging the update from the subversion repository,
the local \emph{Database.xml} has changes which are not yet in the
database. Running \emph{!DeployAll.cmd} updadates the SQL-schema and
produces a new set of generated assemblies in the \emph{CodeGenPath}.
After testing that the merge was successful, use \emph{GetCodeGen.cmd}
to update the working directory with the newly generated bootstrapping
code.

Now the working directory is ready for check in.



