using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

using Kistl.API;
using Kistl.API.Utils;
using Kistl.App.Base;

namespace Kistl.Server.Generators
{
    public abstract class BaseDataObjectGenerator
    {
        private readonly static log4net.ILog Log = log4net.LogManager.GetLogger("Kistl.Server.Generator");

        // Case #1382?
        private string codeBasePath = String.Empty;

        public virtual void Generate(Kistl.API.IKistlContext ctx, string basePath)
        {
            // Case #1382?
            codeBasePath = Path.Combine(basePath, TargetNameSpace);
            Directory.CreateDirectory(codeBasePath);

            Directory.GetFiles(codeBasePath, "*.*", SearchOption.AllDirectories)
                .ToList().ForEach(f => File.Delete(f));
            Directory.GetDirectories(codeBasePath, "*.*", SearchOption.AllDirectories).OrderByDescending(s => s.Length)
                .ToList().ForEach(d => Directory.Delete(d));

            Directory.CreateDirectory(codeBasePath);

            var generatedFileNames = new List<string>();

            Log.Info("  Object Classes");
            foreach (ObjectClass objClass in Generator.GetObjectClassList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_ObjectClass(ctx, objClass));
                Log.Debug("    " + objClass.Name);
            }

            Log.Info("  Collection Entries");
            generatedFileNames.Add(Generate_CollectionEntries(ctx));

            Log.Info("  Interfaces");
            foreach (Interface i in Generator.GetInterfaceList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_Interface(ctx, i));
                Log.Debug("    " + i.Name);
            }

            Log.Info("  Enums");
            foreach (Enumeration e in Generator.GetEnumList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_Enumeration(ctx, e));
                Log.Debug("    " + e.Name);
            }

            Log.Info("  CompoundObjects");
            foreach (CompoundObject s in Generator.GetCompoundObjectList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_CompoundObject(ctx, s));
                Log.Debug("    " + s.Name);                
            }

            Log.Info("  Assemblyinfo");
            generatedFileNames.Add(Generate_AssemblyInfo(ctx));

            Log.Info("  Other Files");
            generatedFileNames.AddRange(Generate_Other(ctx));

            Log.Info("  Project File");
            string projectFileName = Generate_ProjectFile(ctx, ProjectGuid, generatedFileNames);

            // Case #1382
            this.ProjectFileName = Path.Combine(this.codeBasePath, projectFileName);
        }

        /// <summary>
        /// A short string describing the generator for logfiles.
        /// </summary>
        public abstract string Description { get; }

        /// <summary>
        /// the namespace where to lookup the templates of this provider
        /// </summary>
        public string TemplateProviderNamespace { get { return this.GetType().Namespace; } }

        /// <summary>
        /// the assembly where to lookup the templates of this provider
        /// </summary>
        public string TemplateProviderAssembly { get { return this.GetType().Assembly.FullName; } }

        /// <summary>
        /// The namespace which is generated by this provider
        /// </summary>
        public abstract string TargetNameSpace { get; }

        /// <summary>
        /// A short, descriptive string to put into all generated filenames
        /// </summary>
        /// Used as a safety fallback to avoid clashes between files and help orientation
        public abstract string BaseName { get; }

        /// <summary>
        /// Kludge to integrate well into the .sln, in "Registry Format"
        /// </summary>
        public abstract string ProjectGuid { get; }

        /// <summary>
        /// The name of the generated MsBuild project file. This is only available after generating the source code.
        /// </summary>
        public string ProjectFileName { get; private set; }

        protected virtual string RunTemplateWithExtension(IKistlContext ctx, string templateName, string baseFilename, string extension, params object[] args)
        {
            string filename = String.Join(".", new string[] { baseFilename, BaseName, extension });
            return RunTemplate(ctx, templateName, filename, args);
        }

        protected virtual string RunTemplate(IKistlContext ctx, string templateName, string filename, params object[] args)
        {
            var gen = Generator.GetTemplateGenerator(
                TemplateProviderNamespace,
                TemplateProviderAssembly,
                templateName,
                filename,
                this.codeBasePath,
                new object[] { ctx }.Concat(args).ToArray());
            gen.ExecuteTemplate();
            return filename;
        }

        protected virtual string Generate_AssemblyInfo(IKistlContext ctx)
        {
            return RunTemplateWithExtension(ctx, "Implementation.AssemblyInfoTemplate", "AssemblyInfo", "cs");
        }

        protected virtual string Generate_ObjectClass(IKistlContext ctx, ObjectClass objClass)
        {
            return RunTemplateWithExtension(ctx, "Implementation.ObjectClasses.Template", objClass.Name, "Designer.cs", objClass);
        }

        protected virtual string Generate_CollectionEntries(IKistlContext ctx)
        {
            return RunTemplateWithExtension(ctx, "Implementation.ObjectClasses.CollectionEntries", "CollectionEntries", "Designer.cs");
        }

        protected virtual string Generate_Enumeration(IKistlContext ctx, Enumeration e)
        {
            // only used on interface
            return null;
        }

        protected virtual string Generate_CompoundObject(IKistlContext ctx, CompoundObject s)
        {
            return RunTemplateWithExtension(ctx, "Implementation.CompoundObjects.Template", s.Name, "Designer.cs", s);
        }

        protected virtual string Generate_Interface(IKistlContext ctx, Interface i)
        {
            // only used on interface
            return null;
        }

        protected virtual IEnumerable<string> Generate_Other(IKistlContext ctx)
        {
            return new List<string>();
        }

        protected virtual string Generate_ProjectFile(IKistlContext ctx, string projectGuid, List<string> generatedFileNames)
        {
            return RunTemplate(ctx, "Implementation.ProjectFile", TargetNameSpace + ".csproj", projectGuid, generatedFileNames.Where(s => !String.IsNullOrEmpty(s)).ToList());
        }

    }
}
