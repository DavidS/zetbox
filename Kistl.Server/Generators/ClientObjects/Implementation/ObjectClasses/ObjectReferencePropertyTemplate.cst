<%@ CodeTemplate Language="C#" 
	Name="Implementation.ObjectClasses.ObjectReferencePropertyTemplate"
	ClassName="Kistl.Server.Generators.ClientObjects.Implementation.ObjectClasses.ObjectReferencePropertyTemplate" 
	Inherits="Kistl.Server.Generators.KistlCodeTemplate" %>
<%@ Import Namespace="System" %>
<%@ Import Namespace="System.Diagnostics" %>
<%@ Import Namespace="Kistl.API" %>
<%@ Import Namespace="Kistl.API.Server" %>
<%@ Import Namespace="Kistl.App.Base" %>
<%@ Import Namespace="Kistl.App.Extensions" %>
<%@ Import Namespace="Kistl.Server.Generators" %>
<%@ Import Namespace="Kistl.Server.Generators.Extensions" %>
<%@ Parameter Name="ctx" Type="IKistlContext" %>
<%@ Parameter Name="serializationList" Type="Templates.Implementation.SerializationMembersList" %>
<%@ Parameter Name="name" Type="string" %>
<%@ Parameter Name="efName" Type="string" %>
<%@ Parameter Name="fkBackingName" Type="string" %>
<%@ Parameter Name="fkGuidBackingName" Type="string" %>
<%@ Parameter Name="ownInterface" Type="string" %>
<%@ Parameter Name="referencedInterface" Type="string" %>
<%@ Parameter Name="rel" Type="Relation" %>
<%@ Parameter Name="endRole" Type="RelationEndRole" %>
<%@ Parameter Name="hasInverseNavigator" Type="bool" %>
<%@ Parameter Name="hasPositionStorage" Type="bool" %>
<%@ Parameter Name="positionPropertyName" Type="string" %>
<%@ Parameter Name="callGetterSetterEvents" Type="bool" %>
<%
    RelationEnd relEnd = rel.GetEndFromRole(endRole);
    RelationEnd otherEnd = rel.GetOtherEnd(relEnd);
	string eventName = "On" + name;
%>
		// BEGIN <%= this.GetType() %> for <%= name %>
		// rel(<%= endRole %>): <%= rel.A.RoleName %> <%= rel.Verb %> <%= rel.B.RoleName %>
        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public <%= referencedInterface %> <%= name %>
        {
            get
            {
				<%= referencedInterface %> __value;
                if (<%= fkBackingName %>.HasValue)
                    __value = Context.Find<<%= referencedInterface %>>(<%= fkBackingName %>.Value);
                else
                    __value = null;

<%
				if(callGetterSetterEvents)
				{
%>
				if(<%= eventName %>_Getter != null)
				{
					var e = new PropertyGetterEventArgs<<%= referencedInterface %>>(__value);
					<%= eventName %>_Getter(this, e);
					__value = e.Result;
				}
<%
				}
%>
                    
                return __value;
            }
            set
            {
                if (((IPersistenceObject)this).IsReadonly) throw new ReadOnlyObjectException();
                if(value != null && value.Context != this.Context) throw new WrongKistlContextException();
                
                // shortcut noops
                if (value == null && <%= fkBackingName %> == null)
					return;
                else if (value != null && value.ID == <%= fkBackingName %>)
					return;
			           
	            // cache old value to remove inverse references later
                var __oldValue = <%= name %>;
				var __newValue = value;

				// Changing Event fires before anything is touched
				NotifyPropertyChanging("<%= name %>", __oldValue, __newValue);
				
<%
				if(callGetterSetterEvents)
				{
%>
                if(<%= eventName %>_PreSetter != null)
                {
					var e = new PropertyPreSetterEventArgs<<%= referencedInterface %>>(__oldValue, __newValue);
					<%= eventName %>_PreSetter(this, e);
					__newValue = e.Result;
                }
<%
				}
%>
                
				// next, set the local reference
                <%= fkBackingName %> = __newValue == null ? (int?)null : __newValue.ID;
				
<%
    if (hasInverseNavigator)
    {
        var otherProp = otherEnd.Navigator;
        string otherName = otherProp.Name;

%>
				// now fixup redundant, inverse references
				// The inverse navigator will also fire events when changed, so should 
				// only be touched after setting the local value above. 
				// TODO: for complete correctness, the "other" Changing event should also fire 
				//       before the local value is changed
				if (__oldValue != null)
				{
<%
        if (otherProp.IsList())
        {
			// TODO: check whether __oldValue is loaded before potentially triggering a DB Call
%>
					// remove from old list
					(__oldValue.<%= otherName %> as OneNRelationList<<%= ownInterface %>>).RemoveWithoutClearParent(this);
<%
        }
        else
        {
%>
					// unset old reference
					__oldValue.<%= otherName %> = null;
<%
        }
%>
				}

                if (__newValue != null)
                {
<%
        if (otherProp.IsList())
        {
%>
					// add to new list
					(__newValue.<%= otherName %> as OneNRelationList<<%= ownInterface %>>).AddWithoutSetParent(this);
<%
        }
        else
        {
%>
					// set new reference
                    __newValue.<%= otherName %> = this;
<%
        }
%>
                }
<%
    }
%>
				// everything is done. fire the Changed event
				NotifyPropertyChanged("<%= name %>", __oldValue, __newValue);

<%
				if(callGetterSetterEvents)
				{
%>
                if(<%= eventName %>_PostSetter != null)
                {
					var e = new PropertyPostSetterEventArgs<<%= referencedInterface %>>(__oldValue, __newValue);
					<%= eventName %>_PostSetter(this, e);
                }
<%
				}
%>                
            }
        }
        
        private int? <%= fkBackingName %>;
<%
    AddSerialization(serializationList, fkBackingName);

	if (hasPositionStorage)
	{
		Templates.Implementation.ObjectClasses.NotifyingValueProperty.Call(Host, ctx,
		    serializationList,
			"int?", positionPropertyName, "http://dasz.at/Kistl");
	}
%>
		// END <%= this.GetType() %> for <%= name %>
