<%@ CodeTemplate Language="C#" 
	Name="Implementation.ObjectClasses.ObjectReferencePropertyTemplate"
	ClassName="Kistl.Server.Generators.ClientObjects.Implementation.ObjectClasses.ObjectReferencePropertyTemplate" 
	Inherits="Kistl.Server.Generators.KistlCodeTemplate" %>
<%@ Import Namespace="System" %>
<%@ Import Namespace="System.Diagnostics" %>
<%@ Import Namespace="Kistl.API" %>
<%@ Import Namespace="Kistl.API.Server" %>
<%@ Import Namespace="Kistl.App.Base" %>
<%@ Import Namespace="Kistl.App.Extensions" %>
<%@ Import Namespace="Kistl.Server.Generators" %>
<%@ Import Namespace="Kistl.Server.Generators.Extensions" %>
<%@ Parameter Name="ctx" Type="IKistlContext" %>
<%@ Parameter Name="serializationList" Type="Templates.Implementation.SerializationMembersList" %>
<%@ Parameter Name="name" Type="string" %>
<%@ Parameter Name="efName" Type="string" %>
<%@ Parameter Name="fkName" Type="string" %>
<%@ Parameter Name="fkBackingName" Type="string" %>
<%@ Parameter Name="ownInterface" Type="string" %>
<%@ Parameter Name="referencedInterface" Type="string" %>
<%@ Parameter Name="rel" Type="Relation" %>
<%@ Parameter Name="endRole" Type="RelationEndRole" %>
<%@ Parameter Name="hasInverseNavigator" Type="bool" %>
<%@ Parameter Name="hasPositionStorage" Type="bool" %>
<%
    RelationEnd relEnd = rel.GetEnd(endRole);
    RelationEnd otherEnd = rel.GetOtherEnd(relEnd);
%>
        // implement the user-visible interface
        [XmlIgnore()]
        [System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]
        public <%= referencedInterface %> <%= name %>
        {
            get
            {
                if (<%= fkName %>.HasValue)
                    return Context.Find<<%= referencedInterface %>>(<%= fkName %>.Value);
                else
                    return null;
            }
            set
            {
                // TODO: only accept objects from same Context
                if (IsReadonly) throw new ReadOnlyObjectException();
                
                // shortcut noops
                if (value == null && <%= fkBackingName %> == null)
					return;
                else if (value != null && value.ID == <%= fkBackingName %>)
					return;
			           
	            // cache old value to remove inverse references later
                var oldValue = <%= name %>;

				// Changing Event fires before anything is touched
				NotifyPropertyChanging("<%= name %>", oldValue, value);
                
				// next, set the local reference
                <%= fkBackingName %> = value == null ? (int?)null : value.ID;
				
<%
    if (hasInverseNavigator)
    {
        var otherProp = otherEnd.Navigator;
        string otherName = otherProp.PropertyName;

%>
				// now fixup redundant, inverse references
				// The inverse navigator will also fire events when changed, so should 
				// only be touched after setting the local value above. 
				// TODO: for complete correctness, the "other" Changing event should also fire 
				//       before the local value is changed
				if (oldValue != null)
				{
<%
        if (otherProp.IsList)
        {
			// TODO: check whether oldValue is loaded before potentially triggering a DB Call
%>
					// remove from old list
					(oldValue.<%= otherName %> as BackReferenceCollection<<%= ownInterface %>>).RemoveWithoutClearParent(this);
<%
        }
        else
        {
%>
					// unset old reference
					oldValue.<%= otherName %> = null;
<%
        }
%>
				}

                if (value != null)
                {
<%
        if (otherProp.IsList)
        {
%>
					// add to new list
					(value.<%= otherName %> as BackReferenceCollection<<%= ownInterface %>>).AddWithoutSetParent(this);
<%
        }
        else
        {
%>
					// set new reference
                    value.<%= otherName %> = this;
<%
        }
%>
                }
<%
    }
%>
				// everything is done. fire the Changed event
				NotifyPropertyChanged("<%= name %>", oldValue, value);
            }
        }
        
        // provide a way to directly access the foreign key int
        public int? <%= fkName %>
        {
            get
            {
                return <%= fkBackingName %>;
            }
            private set
            {
                if (IsReadonly) throw new ReadOnlyObjectException();
                if (<%= fkBackingName %> != value)
                {
					var __oldValue = <%= fkBackingName %>;
                    NotifyPropertyChanging("<%= name %>", __oldValue, value);
                    <%= fkBackingName %> = value;
                    NotifyPropertyChanged("<%= name %>", __oldValue, value);
                }
            }
        }
        private int? <%= fkBackingName %>;
<%
    AddSerialization(serializationList, fkBackingName);

	string posStorageName = name + Kistl.API.Helper.PositionSuffix;

	if (hasPositionStorage)
	{
		CallTemplate("Implementation.ObjectClasses.NotifyingValueProperty", ctx,
		    serializationList,
			"int?", posStorageName);
	}
%>