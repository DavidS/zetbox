<%@ CodeTemplate Language="C#" 
	Name="Repositories.FrozenContextImplementation"
	ClassName="Kistl.Server.Generators.FrozenObjects.Repositories.FrozenContextImplementation" 
	Inherits="Kistl.Server.Generators.KistlCodeTemplate" %>
<%@ Import Namespace="System" %>
<%@ Import Namespace="System.Collections.Generic" %>
<%@ Import Namespace="System.Linq" %>
<%@ Import Namespace="Kistl.App.Base" %>
<%@ Import Namespace="Kistl.App.Extensions" %>
<%@ Parameter Name="ctx" Type="Kistl.API.IKistlContext" %>
<%@ Parameter Name="modulesWithFrozenClasses" Type="List<Module>" %>
using System;
using System.Collections.Generic;
using System.Linq;

using Kistl.API;

namespace Kistl.App
{

	public class FrozenContextImplementation : IKistlContext
	{
		public FrozenContextImplementation()
		{
		}

		static FrozenContextImplementation()
		{
<%
	foreach(var module in modulesWithFrozenClasses)
	{
%>
				<%= module.Namespace %>.Frozen<%= module.ModuleName %>Repository.CreateInstances();
<%
	}
%>

<%
	foreach(var module in modulesWithFrozenClasses)
	{
%>
				<%= module.Namespace %>.Frozen<%= module.ModuleName %>Repository.FillDataStore();
<%
	}
%>
		}
		

		IPersistenceObject IKistlContext.Attach(IPersistenceObject obj)
		{
			throw new NotImplementedException();
		}
		
		void IKistlContext.Detach(IPersistenceObject obj)
		{
			throw new NotImplementedException();
		}

		void IKistlContext.Delete(IPersistenceObject obj)
		{
			throw new ReadOnlyContextException();
		}

		public IQueryable<T> GetQuery<T>()
			where T : class, IDataObject
		{
			return GetQuery(new InterfaceType(typeof(T))).Cast<T>();
		}

		public IQueryable<IDataObject> GetQuery(InterfaceType ifType)
		{
<%
	foreach(var module in modulesWithFrozenClasses)
	{
	    // TODO: remove ToList when IsFrozenObject correctly inherits across meta-data
		foreach(var frozenCls in module.DataTypes.OfType<ObjectClass>().ToList().Where(cls => cls.IsFrozen()).OrderBy(c => c.ClassName))
		{
%>
			if (ifType == typeof(<%= frozenCls.Module.Namespace %>.<%= frozenCls.ClassName %>))
				return <%= frozenCls.Module.Namespace %>.<%= Implementation.ObjectClasses.Template.GetClassName(frozenCls) %>.DataStore.Values.AsQueryable().Cast<IDataObject>();
<%
		}
	}
%>
			throw new NotImplementedException();
		}

		List<T> IKistlContext.GetListOf<T>(IDataObject obj, string propertyName)
		{
			throw new NotImplementedException();
		}
		
        List<T> IKistlContext.GetListOf<T>(InterfaceType ifType, int ID, string propertyName)
		{
			throw new NotImplementedException();
		}
		
		ICollection<INewCollectionEntry<A, B>> IKistlContext.FetchRelation<A, B>(int relId, RelationEndRole role, IDataObject parent)
		{
			throw new NotImplementedException();
		}

        IPersistenceObject IKistlContext.ContainsObject(InterfaceType type, int ID)
        {
			return Find(type, ID);
        }

        public IEnumerable<IPersistenceObject> AttachedObjects
        {
			get
			{
				return new List<IPersistenceObject>(0)
<%
	foreach(var module in modulesWithFrozenClasses)
	{
		// TODO: remove ToList when IsFrozenObject correctly inherits across meta-data
        foreach(var frozenCls in module.DataTypes.OfType<ObjectClass>().ToList().Where(cls => cls.IsFrozen()).OrderBy(c => c.ClassName))
		{
%>
					.Concat(GetQuery<<%= frozenCls.Module.Namespace %>.<%= frozenCls.ClassName %>>().Cast<IPersistenceObject>())
<%
		}
	}
%>;
			}
		}

        int IKistlContext.SubmitChanges() { throw new NotImplementedException(); }

        bool IKistlContext.IsDisposed { get { return false; } }

        bool IKistlContext.IsReadonly { get { return true; } }

        IDataObject IKistlContext.Create(InterfaceType ifType) { throw new ReadOnlyContextException(); }
        T IKistlContext.Create<T>() { throw new ReadOnlyContextException(); }
        
        ICollectionEntry IKistlContext.CreateCollectionEntry(InterfaceType ifType) { throw new ReadOnlyContextException(); }
        T IKistlContext.CreateCollectionEntry<T>() { throw new ReadOnlyContextException(); }

        IStruct IKistlContext.CreateStruct(InterfaceType ifType) { throw new ReadOnlyContextException(); }
        T IKistlContext.CreateStruct<T>() { throw new ReadOnlyContextException(); }

        public IDataObject Find(InterfaceType ifType, int ID)
		{
<%
	foreach(var module in modulesWithFrozenClasses)
	{
		// TODO: remove ToList when IsFrozenObject correctly inherits across meta-data
		foreach(var frozenCls in module.DataTypes.OfType<ObjectClass>().ToList().Where(cls => cls.IsFrozen()).OrderBy(c => c.ClassName))
		{
%>
			if (ifType == typeof(<%= frozenCls.Module.Namespace %>.<%= frozenCls.ClassName %>))
				return <%= frozenCls.Module.Namespace %>.<%= Implementation.ObjectClasses.Template.GetClassName(frozenCls) %>.DataStore[ID];
<%
		}
	}
%>
			throw new NotImplementedException();
		}

        public T Find<T>(int ID)
			where T : class, IDataObject
        {
			return (T)Find(new InterfaceType(typeof(T)), ID);
        }

        public T FindPersistenceObject<T>(int ID) where T : class, IPersistenceObject
        {
            throw new NotImplementedException();
        }

        public IPersistenceObject FindPersistenceObject(InterfaceType ifType, int ID)
        {
            throw new NotImplementedException();
        }

        IKistlContext IKistlContext.GetReadonlyContext() { throw new NotImplementedException(); }

        event GenericEventHandler<IPersistenceObject> IKistlContext.ObjectCreated
        {
			add { throw new ReadOnlyContextException(); }
			remove { throw new ReadOnlyContextException(); }
		}

        /// <summary>
        /// Is fired when an object is deleted in this Context.
        /// The delted object is passed as Data.
        /// </summary>
        event GenericEventHandler<IPersistenceObject> IKistlContext.ObjectDeleted
        {
			add { throw new ReadOnlyContextException(); }
			remove { throw new ReadOnlyContextException(); }
		}
		
		public virtual void Dispose() {}
	
	}
	
}