using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

using Kistl.API;
using Kistl.App.Base;
using Kistl.API.Utils;

namespace Kistl.Server.Generators
{
    public abstract class BaseDataObjectGenerator
    {
        private readonly static log4net.ILog Log = log4net.LogManager.GetLogger("Kistl.Server.Generator");

        private string codeBasePath = String.Empty;

        public virtual string Generate(Kistl.API.IKistlContext ctx, string basePath)
        {
            codeBasePath = Path.Combine(basePath, TargetNameSpace);
            Directory.CreateDirectory(codeBasePath);

            Directory.GetFiles(codeBasePath, "*.*", SearchOption.AllDirectories)
                .ToList().ForEach(f => File.Delete(f));
            Directory.GetDirectories(codeBasePath, "*.*", SearchOption.AllDirectories).OrderByDescending(s => s.Length)
                .ToList().ForEach(d => Directory.Delete(d));

            Directory.CreateDirectory(codeBasePath);

            var generatedFileNames = new List<string>();


            Log.Info("  Object Classes");
            foreach (ObjectClass objClass in Generator.GetObjectClassList(ctx).OrderBy(x => x.ClassName))
            {
                generatedFileNames.Add(Generate_ObjectClass(ctx, objClass));
                Log.Debug("    " + objClass.ClassName);
            }

            Log.Info("  Collection Entries");
            generatedFileNames.Add(Generate_CollectionEntries(ctx));


            Log.Info("  Interfaces");
            foreach (Interface i in Generator.GetInterfaceList(ctx).OrderBy(x => x.ClassName))
            {
                generatedFileNames.Add(Generate_Interface(ctx, i));
                Log.Debug("    " + i.ClassName);
            }

            Log.Info("  Enums");
            foreach (Enumeration e in Generator.GetEnumList(ctx).OrderBy(x => x.ClassName))
            {
                generatedFileNames.Add(Generate_Enumeration(ctx, e));
                Log.Debug("    " + e.ClassName);
            }

            Log.Info("  Structs");
            foreach (Struct s in Generator.GetStructList(ctx).OrderBy(x => x.ClassName))
            {
                generatedFileNames.Add(Generate_Struct(ctx, s));
                Log.Debug("    " + s.ClassName);                
            }

            Log.Info("  Assemblyinfo");
            generatedFileNames.Add(Generate_AssemblyInfo(ctx));


            Log.Info("  Other Files");
            generatedFileNames.AddRange(Generate_Other(ctx));


            Log.Info("  Project File");
            string projectFileName = Generate_ProjectFile(ctx, ProjectGuid, generatedFileNames);

            return Path.Combine(this.codeBasePath, projectFileName);
        }

        /// <summary>
        /// A short string describing this generator for logfiles.
        /// </summary>
        public abstract string Caption { get; }

        /// <summary>
        /// the namespace where to lookup the templates of this provider
        /// </summary>
        public abstract string TemplateProviderPath { get; }

        /// <summary>
        /// The namespace which is generated by this provider
        /// </summary>
        public abstract string TargetNameSpace { get; }

        /// <summary>
        /// A short, descriptive string to put into all generated filenames
        /// </summary>
        /// Used as a safety fallback to avoid clashes between files and help orientation
        public abstract string BaseName { get; }

        /// <summary>
        /// Kludge to integrate well into the .sln, in "Registry Format"
        /// </summary>
        public abstract string ProjectGuid { get; }

        protected virtual string RunTemplateWithExtension(IKistlContext ctx, string templateName, string baseFilename, string extension, params object[] args)
        {
            string filename = String.Join(".", new string[] { baseFilename, BaseName, extension });
            return RunTemplate(ctx, templateName, filename, args);
        }

        protected virtual string RunTemplate(IKistlContext ctx, string templateName, string filename, params object[] args)
        {
            var gen = Generator.GetTemplateGenerator(
                TemplateProviderPath,
                templateName,
                filename,
                this.codeBasePath,
                new object[] { ctx }.Concat(args).ToArray());
            gen.ExecuteTemplate();
            return filename;
        }

        protected virtual string Generate_AssemblyInfo(IKistlContext ctx)
        {
            return RunTemplateWithExtension(ctx, "Implementation.AssemblyInfoTemplate", "AssemblyInfo", "cs");
        }

        protected virtual string Generate_ObjectClass(IKistlContext ctx, ObjectClass objClass)
        {
            return RunTemplateWithExtension(ctx, "Implementation.ObjectClasses.Template", objClass.ClassName, "Designer.cs", objClass);
        }

        protected virtual string Generate_CollectionEntries(IKistlContext ctx)
        {
            return RunTemplateWithExtension(ctx, "Implementation.ObjectClasses.CollectionEntries", "CollectionEntries", "Designer.cs");
        }

        protected virtual string Generate_Enumeration(IKistlContext ctx, Enumeration e)
        {
            // only used on interface
            return null;
        }

        protected virtual string Generate_Struct(IKistlContext ctx, Struct s)
        {
            return RunTemplateWithExtension(ctx, "Implementation.Structs.Template", s.ClassName, "Designer.cs", s);
        }

        protected virtual string Generate_Interface(IKistlContext ctx, Interface i)
        {
            // only used on interface
            return null;
        }

        protected virtual IEnumerable<string> Generate_Other(IKistlContext ctx)
        {
            return new List<string>();
        }

        protected virtual string Generate_ProjectFile(IKistlContext ctx, string projectGuid, List<string> generatedFileNames)
        {
            return RunTemplate(ctx, "Implementation.ProjectFile", TargetNameSpace + ".csproj", projectGuid, generatedFileNames.Where(s => !String.IsNullOrEmpty(s)).ToList());
        }

    }

    // TODO: load providers from config file
    public static class DataObjectGeneratorFactory
    {
        public static BaseDataObjectGenerator GetInterfaceGenerator()
        {
            return new Interfaces.InterfaceGenerator();
        }
        public static BaseDataObjectGenerator GetClientGenerator()
        {
            return new ClientObjects.ClientObjectGenerator();
        }
        public static BaseDataObjectGenerator GetServerGenerator()
        {
            return new EntityFramework.EntityFrameworkGenerator();
        }
        public static BaseDataObjectGenerator GetFreezingGenerator()
        {
            return new FrozenObjects.FreezingGenerator();
        }
    }
}
