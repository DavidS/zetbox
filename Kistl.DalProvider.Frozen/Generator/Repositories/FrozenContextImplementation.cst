<%@ CodeTemplate Language="C#" 
	Name="Repositories.FrozenContextImplementation"
	ClassName="Kistl.DalProvider.Frozen.Generator.Repositories.FrozenContextImplementation" 
	Inherits="Kistl.Server.Generators.KistlCodeTemplate" %>
<%@ Import Namespace="System" %>
<%@ Import Namespace="System.Collections.Generic" %>
<%@ Import Namespace="System.Linq" %>
<%@ Import Namespace="Kistl.App.Base" %>
<%@ Import Namespace="Kistl.App.Extensions" %>
<%@ Parameter Name="ctx" Type="Kistl.API.IKistlContext" %>
<%@ Parameter Name="modulesWithFrozenClasses" Type="List<Module>" %>
// <autogenerated/>

using System;
using System.Collections.Generic;
using System.Linq;

using Kistl.API;

namespace Kistl.Objects.Frozen
{

	public class FrozenContextImplementation
		: Kistl.DalProvider.Frozen.BaseFrozenContext
	{
		public FrozenContextImplementation(ITypeTransformations typeTrans)
			: base(typeTrans)
		{
		}
	
		static FrozenContextImplementation()
		{
<%
	foreach(var module in modulesWithFrozenClasses)
	{
%>
			<%= module.Namespace %>.Frozen<%= module.Name %>Repository.CreateInstances();
<%
	}
%>

<%
	foreach(var module in modulesWithFrozenClasses)
	{
%>
			<%= module.Namespace %>.Frozen<%= module.Name %>Repository.FillDataStore();
<%
	}
%>
			InitialiseGuidCache(GetAttachedObjects()); 
		}
		
		public override IQueryable<T> GetQuery<T>()
		{
			return GetQuery(typeTrans.AsInterfaceType(typeof(T))).Cast<T>();
		}

		public override IQueryable<IDataObject> GetQuery(InterfaceType ifType)
		{
<%
	foreach(var module in modulesWithFrozenClasses)
	{
	    // TODO: remove ToList when IsFrozenObject correctly inherits across meta-data
		foreach(var frozenCls in module.DataTypes.OfType<ObjectClass>().ToList().Where(cls => cls.IsFrozen()).OrderBy(c => c.Name))
		{
%>
			if (ifType == typeof(<%= frozenCls.Module.Namespace %>.<%= frozenCls.Name %>))
				return <%= frozenCls.Module.Namespace %>.<%= Implementation.ObjectClasses.Template.GetClassName(frozenCls) %>.DataStore.Values.AsQueryable().Cast<IDataObject>();
<%
		}
	}
%>
			throw new NotImplementedException();
		}
		
        public override IEnumerable<IPersistenceObject> AttachedObjects
        {
			get
			{
				return GetAttachedObjects();
			}
		}
		
		private static IEnumerable<IPersistenceObject> GetAttachedObjects() {
			return new List<IPersistenceObject>(0)
<%
	foreach(var module in modulesWithFrozenClasses)
	{
		// TODO: remove ToList when IsFrozenObject correctly inherits across meta-data
        foreach(var frozenCls in module.DataTypes.OfType<ObjectClass>().ToList().Where(cls => cls.IsFrozen()).OrderBy(c => c.Name))
		{
%>
				.Concat(<%= frozenCls.Module.Namespace %>.<%= Implementation.ObjectClasses.Template.GetClassName(frozenCls) %>.DataStore.Values.AsQueryable().Cast<IPersistenceObject>())
<%
		}
	}
%>
				.Distinct();
		}

        public override IDataObject Find(InterfaceType ifType, int ID)
		{
<%
	foreach(var module in modulesWithFrozenClasses)
	{
		// TODO: remove ToList when IsFrozenObject correctly inherits across meta-data
		foreach(var frozenCls in module.DataTypes.OfType<ObjectClass>().ToList().Where(cls => cls.IsFrozen()).OrderBy(c => c.Name))
		{
%>
			if (ifType == typeof(<%= frozenCls.Module.Namespace %>.<%= frozenCls.Name %>))
				return <%= frozenCls.Module.Namespace %>.<%= Implementation.ObjectClasses.Template.GetClassName(frozenCls) %>.DataStore[ID];
<%
		}
	}
%>
			throw new NotImplementedException();
		}

        public override T Find<T>(int ID)
        {
			return (T)Find(typeTrans.AsInterfaceType(typeof(T)), ID);
        }
	}
}