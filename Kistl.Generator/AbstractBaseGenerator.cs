namespace Kistl.Generator
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;
    using Kistl.API;
    using Kistl.API.Server;
    using Kistl.API.Utils;
    using Kistl.App.Base;

    public abstract class AbstractBaseGenerator
    {
        private readonly static log4net.ILog Log = log4net.LogManager.GetLogger("Kistl.Server.Generator");

        private readonly IEnumerable<ISchemaProvider> _schemaProviders;
        protected IEnumerable<ISchemaProvider> SchemaProviders
        {
            get { return _schemaProviders; }
        }

        protected AbstractBaseGenerator(IEnumerable<ISchemaProvider> schemaProviders)
        {
            _schemaProviders = schemaProviders;
        }

        // Case #1382?
        protected string CodeBasePath { get; private set; }

        public virtual void Generate(Kistl.API.IKistlContext ctx, string basePath)
        {
            // Case #1382?
            CodeBasePath = Path.Combine(basePath, TargetNameSpace);
            Directory.CreateDirectory(CodeBasePath);

            Directory.GetFiles(CodeBasePath, "*.*", SearchOption.AllDirectories)
                .ToList().ForEach(f => File.Delete(f));
            Directory.GetDirectories(CodeBasePath, "*.*", SearchOption.AllDirectories).OrderByDescending(s => s.Length)
                .ToList().ForEach(d => Directory.Delete(d));

            Directory.CreateDirectory(CodeBasePath);

            // Save KeyFile
            using (var snkSrc = typeof(AbstractBaseGenerator).Assembly.GetManifestResourceStream("Kistl.Generator.Kistl.Objects.snk"))
            using (var snkDest = File.Open(Path.Combine(CodeBasePath, "Kistl.Objects.snk"), FileMode.Create))
            {
                snkDest.SetLength(0);
                snkSrc.CopyTo(snkDest);
            }

            var generatedFileNames = new List<string>();

            Log.Info("  Object Classes");
            foreach (ObjectClass objClass in Compiler.GetObjectClassList(ctx).OrderBy(x => x.Name).ToList())
            {
                generatedFileNames.Add(Generate_ObjectClass(ctx, objClass));
                Log.Debug("    " + objClass.Name);
            }

            Log.Info("  Collection Entries");
            generatedFileNames.Add(Generate_CollectionEntries(ctx));

            Log.Info("  Interfaces");
            foreach (Interface i in Compiler.GetInterfaceList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_Interface(ctx, i));
                Log.Debug("    " + i.Name);
            }

            Log.Info("  Enums");
            foreach (Enumeration e in Compiler.GetEnumList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_Enumeration(ctx, e));
                Log.Debug("    " + e.Name);
            }

            Log.Info("  CompoundObjects");
            foreach (CompoundObject s in Compiler.GetCompoundObjectList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_CompoundObject(ctx, s));
                Log.Debug("    " + s.Name);
            }

            Log.Info("  Assemblyinfo");
            generatedFileNames.Add(Generate_AssemblyInfo(ctx));

            Log.Info("  Other Files");
            generatedFileNames.AddRange(Generate_Other(ctx));

            Log.Info("  Project File");
            string projectFileName = Generate_ProjectFile(ctx, ProjectGuid, generatedFileNames, _schemaProviders);

            // Case #1382
            this.ProjectFileName = Path.Combine(this.CodeBasePath, projectFileName);
        }

        /// <summary>
        /// A short string describing the generator for logfiles and namespaces.
        /// </summary>
        public abstract string Description { get; }

        /// <summary>
        /// the namespace where to lookup the templates of this provider
        /// </summary>
        public virtual string TemplateProviderNamespace { get { return this.GetType().Namespace + ".Templates"; } }

        /// <summary>
        /// the assembly where to lookup the templates of this provider
        /// </summary>
        public string TemplateProviderAssembly { get { return this.GetType().Assembly.FullName; } }

        /// <summary>
        /// A extra suffix added to all class names, to allow distinguish them when debugging.
        /// </summary>
        public abstract string ExtraSuffix { get; }

        /// <summary>
        /// The namespace which is generated by this provider
        /// </summary>
        public abstract string TargetNameSpace { get; }

        /// <summary>
        /// A short, descriptive string to put into all generated filenames
        /// </summary>
        /// Used as a safety fallback to avoid clashes between files and help orientation
        public abstract string BaseName { get; }

        /// <summary>
        /// Kludge to integrate well into the .sln, in "Registry Format"
        /// </summary>
        public abstract string ProjectGuid { get; }

        /// <summary>
        /// The name of the generated MsBuild project file. This is only available after generating the source code.
        /// </summary>
        public string ProjectFileName { get; private set; }

        /// <summary>
        /// Required Namespaces for this project
        /// </summary>
        public abstract IEnumerable<string> RequiredNamespaces { get; }

        protected virtual string RunTemplateWithExtension(IKistlContext ctx, string templateName, string baseFilename, string extension, params object[] args)
        {
            string filename = String.Join(".", new string[] { baseFilename, BaseName, extension });
            return RunTemplate(ctx, templateName, filename, args);
        }

        protected virtual string RunTemplate(IKistlContext ctx, string templateName, string filename, params object[] args)
        {
            var gen = new TemplateExecutor();

            gen.Settings.Add("basetemplatepath", "Kistl.Generator.Templates");
            gen.Settings.Add("providertemplatenamespace", TemplateProviderNamespace);
            gen.Settings.Add("providertemplateassembly", TemplateProviderAssembly);

            gen.Settings.Add("template", templateName);

            gen.Settings.Add("targetdir", this.CodeBasePath);
            gen.Settings.Add("output", filename);
            gen.Settings.Add("logfile", "TemplateCodegenLog.txt");

            gen.Settings.Add("extrasuffix", ExtraSuffix);
            gen.Settings.Add("namespaces", String.Join(",", RequiredNamespaces.ToArray()));
            gen.Settings.Add("implementationnamespace", "Kistl.DalProvider." + BaseName);

            gen.TemplateParameters = new object[] { ctx }.Concat(args).ToArray();

            gen.ExecuteTemplate();

            return filename;
        }

        protected virtual string Generate_AssemblyInfo(IKistlContext ctx)
        {
            return RunTemplateWithExtension(ctx, "AssemblyInfoTemplate", "AssemblyInfo", "cs");
        }

        protected virtual string Generate_ObjectClass(IKistlContext ctx, ObjectClass objClass)
        {
            return RunTemplateWithExtension(ctx, "ObjectClasses.Template", objClass.Name, "Designer.cs", objClass);
        }

        protected virtual string Generate_CollectionEntries(IKistlContext ctx)
        {
            return RunTemplateWithExtension(ctx, "ObjectClasses.CollectionEntries", "CollectionEntries", "Designer.cs");
        }

        protected virtual string Generate_Enumeration(IKistlContext ctx, Enumeration e)
        {
            // only used on interface
            return null;
        }

        protected virtual string Generate_CompoundObject(IKistlContext ctx, CompoundObject s)
        {
            return RunTemplateWithExtension(ctx, "CompoundObjects.Template", s.Name, "Designer.cs", s);
        }

        protected virtual string Generate_Interface(IKistlContext ctx, Interface i)
        {
            // only used on interface
            return null;
        }

        protected virtual IEnumerable<string> Generate_Other(IKistlContext ctx)
        {
            return new List<string>()
            {
                RunTemplateWithExtension(ctx, "Module", "Module", "cs", Description)
            };
        }

        protected virtual string Generate_ProjectFile(IKistlContext ctx, string projectGuid, List<string> generatedFileNames, IEnumerable<ISchemaProvider> schemaProviders)
        {
            return RunTemplate(ctx, "ProjectFile",
                TargetNameSpace + ".csproj",
                projectGuid,
                generatedFileNames.Where(s => !String.IsNullOrEmpty(s)).ToList(),
                schemaProviders);
        }
    }
}
