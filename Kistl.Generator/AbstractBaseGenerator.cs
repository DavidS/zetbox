namespace Kistl.Generator
{
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Text;
    using Kistl.API;
    using Kistl.API.Server;
    using Kistl.API.Utils;
    using Kistl.App.Base;

    public abstract class AbstractBaseGenerator
    {
        private readonly static log4net.ILog Log = log4net.LogManager.GetLogger("Kistl.Generator");

        private readonly IEnumerable<ISchemaProvider> _schemaProviders;
        protected IEnumerable<ISchemaProvider> SchemaProviders
        {
            get { return _schemaProviders; }
        }

        protected AbstractBaseGenerator(IEnumerable<ISchemaProvider> schemaProviders)
        {
            _schemaProviders = schemaProviders;
        }

        // Case #1382?
        protected string CodeBasePath { get; private set; }

        public virtual void Generate(Kistl.API.IKistlContext ctx, string basePath)
        {
            InitCodeBasePath(basePath);
            Directory.CreateDirectory(CodeBasePath);
            DeleteOldFiles();

            SaveKeyFile();

            var generatedFileNames = new List<string>();

            generatedFileNames.AddRange(Generate_Objects(ctx));

            Log.Info("  Assemblyinfo");
            generatedFileNames.Add(Generate_AssemblyInfo(ctx));

            Log.Info("  Other Files");
            generatedFileNames.AddRange(Generate_Other(ctx));

            Log.Info("  Project File");
            Generate_ProjectFile(ctx, ProjectGuid, generatedFileNames, _schemaProviders);
        }

        protected virtual void SaveKeyFile()
        {
            // Save KeyFile
            using (var snkSrc = typeof(AbstractBaseGenerator).Assembly.GetManifestResourceStream("Kistl.Generator.Kistl.Objects.snk"))
            using (var snkDest = File.Open(Path.Combine(CodeBasePath, "Kistl.Objects.snk"), FileMode.Create))
            {
                snkDest.SetLength(0);
                snkSrc.CopyTo(snkDest);
            }
        }

        protected virtual void DeleteOldFiles()
        {
            Directory.GetFiles(CodeBasePath, "*.*", SearchOption.AllDirectories)
                .ToList().ForEach(f => File.Delete(f));
            Directory.GetDirectories(CodeBasePath, "*.*", SearchOption.AllDirectories).OrderByDescending(s => s.Length)
                .ToList().ForEach(d => Directory.Delete(d));
        }

        protected virtual void InitCodeBasePath(string basePath)
        {
            // Case #1382?
            CodeBasePath = Path.Combine(basePath, TargetNameSpace);
        }

        public const int COMPILE_ORDER_Interface = 1;
        public const int COMPILE_ORDER_Implementation = 10;
        public const int COMPILE_ORDER_Other = 20;

        /// <summary>
        /// Order of compiling
        /// </summary>
        public abstract int CompileOrder { get; }

        /// <summary>
        /// A short string describing the generator for logfiles and namespaces.
        /// </summary>
        public abstract string Description { get; }

        /// <summary>
        /// the namespace where to lookup the templates of this provider
        /// </summary>
        public virtual string TemplateProviderNamespace { get { return this.GetType().Namespace + ".Templates"; } }

        /// <summary>
        /// the assembly where to lookup the templates of this provider
        /// </summary>
        public string TemplateProviderAssembly { get { return this.GetType().Assembly.FullName; } }

        /// <summary>
        /// A extra suffix added to all class names, to allow distinguish them when debugging.
        /// </summary>
        public abstract string ExtraSuffix { get; }

        /// <summary>
        /// The namespace which is generated by this provider
        /// </summary>
        public abstract string TargetNameSpace { get; }

        /// <summary>
        /// A short, descriptive string to put into all generated filenames
        /// </summary>
        /// Used as a safety fallback to avoid clashes between files and help orientation
        public abstract string BaseName { get; }

        /// <summary>
        /// Kludge to integrate well into the .sln, in "Registry Format"
        /// </summary>
        public abstract string ProjectGuid { get; }

        /// <summary>
        /// The name of the generated MsBuild project file.
        /// </summary>
        public string ProjectFileName { get { return TargetNameSpace + ".csproj"; } }

        /// <summary>
        /// The type name of the custom PropertyDescriptor.
        /// </summary>
        public virtual string CustomPropertyDescriptorName { get { return "PropertyDescriptor" + ExtraSuffix + Kistl.API.Helper.ImplementationSuffix; } }

        /// <summary>
        /// List of aditional build targets, executed after all default targets has been build
        /// </summary>
        public virtual IEnumerable<string> AdditionalTargets { get { return new string[] { }; } }

        /// <summary>
        /// Required Namespaces for this project
        /// </summary>
        public abstract IEnumerable<string> RequiredNamespaces { get; }

        protected virtual string RunTemplateWithExtension(IKistlContext ctx, string templateName, string baseFilename, string extension, params object[] args)
        {
            string filename = String.Join(".", new string[] { baseFilename, BaseName, extension });
            return RunTemplate(ctx, templateName, filename, args);
        }

        protected virtual string RunTemplate(IKistlContext ctx, string templateName, string filename, params object[] args)
        {
            try
            {
                var gen = new TemplateExecutor();

                gen.Settings.Add("basetemplatepath", "Kistl.Generator.Templates");
                gen.Settings.Add("providertemplatenamespace", TemplateProviderNamespace);
                gen.Settings.Add("providertemplateassembly", TemplateProviderAssembly);

                gen.Settings.Add("template", templateName);

                gen.Settings.Add("targetdir", this.CodeBasePath);
                gen.Settings.Add("output", filename);
                gen.Settings.Add("logfile", "TemplateCodegenLog.txt");

                gen.Settings.Add("extrasuffix", ExtraSuffix);
                gen.Settings.Add("namespaces", String.Join(",", RequiredNamespaces.ToArray()));
                gen.Settings.Add("implementationnamespace", "Kistl.DalProvider." + BaseName);

                gen.Settings.Add("propertydescriptorname", CustomPropertyDescriptorName);

                gen.TemplateParameters = new object[] { ctx }.Concat(args).ToArray();

                gen.ExecuteTemplate();

                return filename;
            }
            catch (Exception ex)
            {
                var msg = String.Format("Error while rendering template [{0}] to [{1}]", templateName, filename);
                Log.Error(msg, ex);
                throw new ApplicationException(msg, ex);
            }
        }

        protected virtual string Generate_AssemblyInfo(IKistlContext ctx)
        {
            return RunTemplateWithExtension(ctx, "AssemblyInfoTemplate", "AssemblyInfo", "cs");
        }

        protected virtual string Generate_ObjectClass(IKistlContext ctx, ObjectClass objClass)
        {
            return RunTemplateWithExtension(ctx, "ObjectClasses.Template", objClass.Name, "Designer.cs", objClass);
        }

        protected virtual string Generate_CollectionEntries(IKistlContext ctx)
        {
            return RunTemplateWithExtension(ctx, "ObjectClasses.CollectionEntries", "CollectionEntries", "Designer.cs");
        }

        protected virtual string Generate_Enumeration(IKistlContext ctx, Enumeration e)
        {
            // only used on interface
            return null;
        }

        protected virtual string Generate_CompoundObject(IKistlContext ctx, CompoundObject s)
        {
            return RunTemplateWithExtension(ctx, "CompoundObjects.Template", s.Name, "Designer.cs", s);
        }

        protected virtual string Generate_Interface(IKistlContext ctx, Interface i)
        {
            // only used on interface
            return null;
        }

        protected virtual IEnumerable<string> Generate_Other(IKistlContext ctx)
        {
            return new List<string>()
            {
                RunTemplateWithExtension(ctx, "Module", "Module", "cs", Description)
            };
        }

        protected virtual string Generate_ProjectFile(IKistlContext ctx, string projectGuid, List<string> generatedFileNames, IEnumerable<ISchemaProvider> schemaProviders)
        {
            return RunTemplate(ctx, "ProjectFile",
                ProjectFileName,
                projectGuid,
                generatedFileNames.Where(s => !String.IsNullOrEmpty(s)).ToList(),
                schemaProviders);
        }

        protected virtual List<string> Generate_Objects(Kistl.API.IKistlContext ctx)
        {
            var generatedFileNames = new List<string>();

            Log.Info("  Object Classes");
            foreach (ObjectClass objClass in Compiler.GetObjectClassList(ctx).OrderBy(x => x.Name).ToList())
            {
                generatedFileNames.Add(Generate_ObjectClass(ctx, objClass));
                Log.Debug("    " + objClass.Name);
            }

            Log.Info("  Collection Entries");
            generatedFileNames.Add(Generate_CollectionEntries(ctx));

            Log.Info("  Interfaces");
            foreach (Interface i in Compiler.GetInterfaceList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_Interface(ctx, i));
                Log.Debug("    " + i.Name);
            }

            Log.Info("  Enums");
            foreach (Enumeration e in Compiler.GetEnumList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_Enumeration(ctx, e));
                Log.Debug("    " + e.Name);
            }

            Log.Info("  CompoundObjects");
            foreach (CompoundObject s in Compiler.GetCompoundObjectList(ctx).OrderBy(x => x.Name))
            {
                generatedFileNames.Add(Generate_CompoundObject(ctx, s));
                Log.Debug("    " + s.Name);
            }

            return generatedFileNames;
        }
    }
}
