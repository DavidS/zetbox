R: Gendarme.Rules.Correctness.DisposableFieldsShouldBeDisposedRule
# these classes have special disposal strategies since they need to hold disposable parts with lifecycles beyond themselves
T: Kistl.Server.SchemaManagement.Cases
T: Kistl.Server.SchemaManagement.SchemaManager

R: Gendarme.Rules.Serialization.MarkAllNonSerializableFieldsRule
# automatically generated code
T: Kistl.API.Client.KistlService.InternalCache
T: Kistl.API.Client.KistlService.InternalCacheItem

R: Gendarme.Rules.Design.Linq.AvoidExtensionMethodOnSystemObjectRule
# These infrastructure methods are only helpers intended for a very small audience
# so I don't care much about VB.Net in these cases
T: Kistl.API.GetSetHasValueExtensions
T: Kistl.API.ExtensionHelpers

R: Gendarme.Rules.BadPractice.ConstructorShouldNotCallVirtualMethodsRule
# private type where the brittle-ness doesn't matter
T: Kistl.API.Utils.Logging/TraceMethodCallContext

R: Gendarme.Rules.BadPractice.AvoidCallingProblematicMethodsRule
# automatically generated code
T: System.Delegate XamlGeneratedNamespace.GeneratedInternalTypeHelper
# infrastructure helper method intended for a very small audience
T: System.Void Kistl.API.GetSetHasValueExtensions

R: Gendarme.Rules.Performance.AvoidUncalledPrivateCodeRule
# This method is flagged with a ConditionalAttribute
M: System.Void Kistl.API.BinarySerializer::SerializerTrace(System.String,System.Object[])
# Helper method which is only called by reflection from AddNewLocalObjects
M: System.Void Kistl.API.Client.KistlContextProvider::AddNewLocalObjectsGeneric(System.Collections.IList)
# Helper method which is only called by reflection from GetCollectionEntries
M: System.Collections.Generic.IEnumerable`1<Kistl.API.IRelationCollectionEntry> Kistl.DalProvider.EF.ServerCollectionHandler`4::GetCollectionEntriesInternal(TParent,Kistl.App.Base.Relation,Kistl.API.RelationEndRole)
# generated code (wpf)
M: System.Delegate Kistl.Client.WPF.View.KistlBase.DataObjectLineDisplay::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.KistlBase.ObjectReferenceEditor::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.KistlBase.StringDisplay::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.KistlBase.TypeRefPropertyView::_CreateDelegate(System.Type,System.String)

M: System.Delegate Kistl.Client.WPF.View.ObjectEditor.DataObjectEditor::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.ObjectEditor.WorkspaceDisplay::_CreateDelegate(System.Type,System.String)

M: System.Delegate Kistl.Client.WPF.View.ObjectBrowser.WorkspaceDisplay::_CreateDelegate(System.Type,System.String)

M: System.Delegate Kistl.Client.WPF.View.ModuleEditor.ObjectClassInstanceList::_CreateDelegate(System.Type,System.String)

M: System.Delegate Kistl.Client.WPF.View.Relations.RelationEndEditor::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.Relations.RelationEditor::_CreateDelegate(System.Type,System.String)

M: System.Delegate Kistl.Client.WPF.View.SelectionDialog::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.LabeledView::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.TimeRecords.WorkEffortRecorderView::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.EnumSelectionView::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.NullableBoolValueView::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.NullablePropertyTextBoxView::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.TextValueSelectionView::_CreateDelegate(System.Type,System.String)
M: System.Delegate Kistl.Client.WPF.View.CacheDebuggerDisplay::_CreateDelegate(System.Type,System.String)

R: Gendarme.Rules.Correctness.CheckParametersNullityInVisibleMethodsRule
# MethodInvocation implementors should not have to check for thisobj==null => too many false positives
A: Kistl.App.Projekte.Common
A: Kistl.App.Projekte.Client
A: Kistl.App.Projekte.Server
# False positives
M: System.Void Kistl.DalProvider.EF.EntityCollectionWrapper`2::Add(TInterface)
M: System.Boolean Kistl.DalProvider.EF.EntityCollectionWrapper`2::Contains(TInterface)
M: System.Boolean Kistl.DalProvider.EF.EntityCollectionWrapper`2::Remove(TInterface)
M: System.Void Kistl.DalProvider.EF.EntityCollectionWrapper`2::CopyTo(System.Array,System.Int32)

R: Gendarme.Rules.Portability.DoNotHardcodePathsRule
# Package URIs are FS-independent
M: System.Void Kistl.App.Projekte.WordHelper::ApplyCustomXml(System.Xml.XmlDocument)

R: Gendarme.Rules.Portability.MonoCompatibilityReviewRule
# exclude known not-implemented parts: WPF, EF
A: Kistl.Client.WPF
A: Kistl.DalProvider.EF
# this should be replaced in time for a linux-release, ignore for now
M: System.Void Kistl.Server.Generators.Generator::CompileCode(System.String)
M: System.Void Kistl.Server.Server::ReadUsers(System.String,System.Collections.Generic.Dictionary`2<System.String,System.String>)

R: Gendarme.Rules.Correctness.EnsureLocalDisposalRule
# false positives when returning an IEnumerator from GetEnumerator
M: System.Collections.IEnumerator Kistl.API.BaseRelationCollectionWrapper`6::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.API.Utils.ReadOnlyProjectedCollection`2::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.API.Utils.ContextCache::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.API.Utils.GenericCastingCollectionWrapper`2::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.API.Utils.SortListFromCollection`2::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.API.Utils.LookupDictionary`3::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.API.ValueCollectionWrapper`4::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.API.Client.BaseRelationshipFilterCollection`1::System.Collections.IEnumerable.GetEnumerator()
# the following are compiler generated stuff, sometimes these may change in the d__X part :-/
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.View.DataObjectReferenceView/<GetScriptDescriptors>d__0::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.View.DataObjectReferenceView/<GetScriptReferences>d__4::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.View.LauchnerView/<GetScriptDescriptors>d__0::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.View.LauchnerView/<GetScriptReferences>d__4::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.JavascriptRenderer/<GetScriptDescriptors>d__0::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.JavascriptRenderer/<GetScriptReferences>d__3::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.Dialogs.ChooseObjectDialog/<GetScriptDescriptors>d__0::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.Dialogs.ChooseObjectDialog/<GetScriptReferences>d__3::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.View.WorkspaceView/<GetScriptDescriptors>d__2::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.View.WorkspaceView/<GetScriptReferences>d__6::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.View.DataObjectListView/<GetScriptDescriptors>d__4::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Client.ASPNET.Toolkit.View.DataObjectListView/<GetScriptReferences>d__8::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.DalProvider.EF.EntityCollectionWrapper`2::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Server.SchemaManagement.SqlProvider.SqlServer/<GetTableNames>d__0::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Server.SchemaManagement.SqlProvider.SqlServer/<GetFKConstraintNames>d__9::System.Collections.IEnumerable.GetEnumerator()
M: System.Collections.IEnumerator Kistl.Server.SchemaManagement.SqlProvider.SqlServer/<GetTableColumnNames>d__11::System.Collections.IEnumerable.GetEnumerator()
# false positives when working with ASP.Net's ScriptManager
M: System.Void Kistl.Client.ASPNET.Toolkit.View.DataObjectReferenceView::OnPreRender(System.EventArgs)
M: System.Void Kistl.Client.ASPNET.Toolkit.View.LauchnerView::OnPreRender(System.EventArgs)
M: System.Void Kistl.Client.ASPNET.Toolkit.JavascriptRenderer::OnPreRender(System.EventArgs)
M: System.Void Kistl.Client.ASPNET.Toolkit.Dialogs.ChooseObjectDialog::OnPreRender(System.EventArgs)
M: System.Void Kistl.Client.ASPNET.Toolkit.View.WorkspaceView::OnPreRender(System.EventArgs)
M: System.Void Kistl.Client.ASPNET.Toolkit.View.DataObjectListView::OnPreRender(System.EventArgs)
# factory method to create this object and pass it on
M: System.Void Kistl.Client.Presentables.ObjectBrowser.CreateNewInstanceExternallyCommand::DoExecute(System.Object)
M: System.Void Kistl.Client.Presentables.KistlBase.OpenApplicatonCommand::DoExecute(System.Object)
M: System.Void Kistl.Client.ASPNET.Toolkit.KistlContextManagerModule::context_BeginRequest(System.Object,System.EventArgs)
M: System.Void Kistl.Client.ASPNET.Toolkit.View.WorkspaceView::RecentObjects_CollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)
M: System.Object Kistl.Client.ASPNET.Toolkit.AspnetModelFactoryExtensions::AddControl(System.Web.UI.Control,System.Object)
M: System.Void Kistl.Client.ASPNET.Toolkit.View.DataObjectFullView::repProperties_OnItemDataBound(System.Object,System.Web.UI.WebControls.RepeaterItemEventArgs)
M: System.Void Kistl.Client.Forms.FormsModelFactory::CreateWorkspace(Kistl.Client.Presentables.ObjectBrowser.WorkspaceViewModel,System.Boolean)
M: System.Void Kistl.Client.Forms.View.DataObjectFullView::SyncProperties()
M: System.Void Kistl.Client.WPF.View.ObjectBrowser.InstanceListDisplay::Edit_Click(System.Object,System.Windows.RoutedEventArgs)
M: System.Void Kistl.Client.WPF.View.ObjectBrowser.InstanceListDisplay::New_Click(System.Object,System.Windows.RoutedEventArgs)
M: System.Void Kistl.Client.WPF.View.ModuleEditor.InstanceListDisplay::New_Click(System.Object,System.Windows.RoutedEventArgs)
# object is "bound" to the process' life cycle, no disposal necessary
M: System.Void Kistl.Server.WcfServer::Init(Kistl.API.Configuration.KistlConfig)
M: System.Void Kistl.Server.Service.Program::XmlFallbackInitialisation(System.String)
M: Kistl.API.Configuration.KistlConfig Kistl.Server.Service.Program::InitApplicationContext(System.String[])
M: System.Void Kistl.Server.Service.ServerManager::Start(Kistl.API.Configuration.KistlConfig)

# see https://bugzilla.novell.com/show_bug.cgi?id=567995 , should be fixed in gendarme 2.8
R: Gendarme.Rules.Exceptions.InstantiateArgumentExceptionCorrectlyRule
M: TItem Kistl.API.BaseRelationListWrapper`6::get_Item(System.Int32)
M: System.Void Kistl.API.BaseRelationListWrapper`6::set_Item(System.Int32,TItem)
M: TValue Kistl.API.ValueListWrapper`4::get_Item(System.Int32)
M: System.Void Kistl.API.ValueListWrapper`4::set_Item(System.Int32,TValue)
M: TInterface Kistl.DalProvider.EF.EntityListWrapper`2::get_Item(System.Int32)
M: System.Void Kistl.DalProvider.EF.EntityListWrapper`2::set_Item(System.Int32,TInterface)
M: System.Collections.IEnumerable Kistl.API.Utils.ContextCache::get_Item(Kistl.API.InterfaceType)

R: Gendarme.Rules.Correctness.ProvideCorrectArgumentsToFormattingMethodsRule
# Format string build during runtime
M: System.Void Kistl.Server.SchemaManagement.SqlProvider.SqlServer::CreateUpdateRightsTrigger(System.String,System.String,System.Collections.Generic.List`1<Kistl.API.Server.RightsTrigger>)

###############################################################################
##  GLOBAL IGNORES  ###########################################################
###############################################################################

# Too simple-minded rule.
R: Gendarme.Rules.Design.Generic.DoNotExposeNestedGenericSignaturesRule
A: Kistl.API
A: Kistl.App.Projekte.Common
A: Kistl.DalProvider.Frozen
A: TempAppHelpers
A: Kistl.API.Client
A: Kistl.App.Projekte.Client
A: Kistl.Client.ASPNET.Toolkit
A: Kistl.Client
A: Kistl.Client.Forms
A: Kistl.Client.WPF
A: Kistl.DalProvider.ClientObjects
A: Kistl.API.Server
A: Kistl.App.Projekte.Server
A: Kistl.DalProvider.EF
A: Kistl.Server
A: Kistl.Server.Service

# implementing the suggested fix brings only switches the direction of the race-condition:
# i.e. calling a delegate that doesn't expect to be called any more
# fixing this requires protection outside of the event calling
R: Gendarme.Rules.Concurrency.ProtectCallToEventDelegatesRule
A: Kistl.API
A: Kistl.App.Projekte.Common
A: Kistl.DalProvider.Frozen
A: TempAppHelpers
A: Kistl.API.Client
A: Kistl.App.Projekte.Client
A: Kistl.Client.ASPNET.Toolkit
A: Kistl.Client
A: Kistl.Client.Forms
A: Kistl.Client.WPF
A: Kistl.DalProvider.ClientObjects
A: Kistl.API.Server
A: Kistl.App.Projekte.Server
A: Kistl.DalProvider.EF
A: Kistl.Server
A: Kistl.Server.Service

# Too many false positives with classes that have a reference to an IKistlContext
R: Gendarme.Rules.Design.TypesWithDisposableFieldsShouldBeDisposableRule
A: Kistl.API
A: Kistl.App.Projekte.Common
A: Kistl.DalProvider.Frozen
A: TempAppHelpers
A: Kistl.API.Client
A: Kistl.App.Projekte.Client
A: Kistl.Client.ASPNET.Toolkit
A: Kistl.Client
A: Kistl.Client.Forms
A: Kistl.Client.WPF
A: Kistl.DalProvider.ClientObjects
A: Kistl.API.Server
A: Kistl.App.Projekte.Server
A: Kistl.DalProvider.EF
A: Kistl.Server
A: Kistl.Server.Service

# Flags mostly generated code or Presentable models, which generally have little cohesion.
R: Gendarme.Rules.Maintainability.AvoidLackOfCohesionOfMethodsRule
A: Kistl.API
A: Kistl.App.Projekte.Common
A: Kistl.DalProvider.Frozen
A: TempAppHelpers
A: Kistl.API.Client
A: Kistl.App.Projekte.Client
A: Kistl.Client.ASPNET.Toolkit
A: Kistl.Client
A: Kistl.Client.Forms
A: Kistl.Client.WPF
A: Kistl.DalProvider.ClientObjects
A: Kistl.API.Server
A: Kistl.App.Projekte.Server
A: Kistl.DalProvider.EF
A: Kistl.Server
A: Kistl.Server.Service

# too many false positives while developing
R: Gendarme.Rules.BadPractice.DoNotForgetNotImplementedMethodsRule
A: Kistl.API
A: Kistl.App.Projekte.Common
A: Kistl.DalProvider.Frozen
A: TempAppHelpers
A: Kistl.API.Client
A: Kistl.App.Projekte.Client
A: Kistl.Client.ASPNET.Toolkit
A: Kistl.Client
A: Kistl.Client.Forms
A: Kistl.Client.WPF
A: Kistl.DalProvider.ClientObjects
A: Kistl.API.Server
A: Kistl.App.Projekte.Server
A: Kistl.DalProvider.EF
A: Kistl.Server
A: Kistl.Server.Service

# const considered harmful
R: Gendarme.Rules.Performance.PreferLiteralOverInitOnlyFieldsRule
A: Kistl.API
A: Kistl.App.Projekte.Common
A: Kistl.DalProvider.Frozen
A: TempAppHelpers
A: Kistl.API.Client
A: Kistl.App.Projekte.Client
A: Kistl.Client.ASPNET.Toolkit
A: Kistl.Client
A: Kistl.Client.Forms
A: Kistl.Client.WPF
A: Kistl.DalProvider.ClientObjects
A: Kistl.API.Server
A: Kistl.App.Projekte.Server
A: Kistl.DalProvider.EF
A: Kistl.Server
A: Kistl.Server.Service


